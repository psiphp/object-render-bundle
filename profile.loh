FUNCTION  syntastic#log#debugShowOptions()
Called 2 times
Total time:   0.000016
 Self time:   0.000011

count  total (s)   self (s)
    2   0.000013   0.000008     if !s:_isDebugEnabled(a:level)
    2              0.000002         return
                                endif
                            
                                let leader = s:_log_timestamp()
                                call s:_logRedirect(1)
                            
                                let vlist = copy(type(a:names) == type('') ? [a:names] : a:names)
                                let add_shell = index(vlist, 'shell') >= 0 && &shell !=# syntastic#util#var('shell')
                                if !empty(vlist)
                                    call map(vlist, "'&' . v:val . ' = ' . strtrans(string(eval('&' . v:val))) . (s:_is_modified(v:val) ? ' (!)' : '')")
                                    if add_shell
                                        call add(vlist, 'u:shell = ' . strtrans(string(syntastic#util#var('shell'))) . ' (!)')
                                    endif
                                    echomsg leader . join(vlist, ', ')
                                endif
                                call s:_logRedirect(0)

FUNCTION  syntastic#log#debug()
Called 47 times
Total time:   0.000559
 Self time:   0.000363

count  total (s)   self (s)
   47   0.000461   0.000265     if !s:_isDebugEnabled(a:level)
   47              0.000055         return
                                endif
                            
                                let leader = s:_log_timestamp()
                                call s:_logRedirect(1)
                            
                                if a:0
                                    " filter out dictionary functions
                                    echomsg leader . a:msg . ' ' . strtrans(string(type(a:1) == type({}) || type(a:1) == type([]) ? filter(copy(a:1), 'type(v:val) != type(function("tr"))') : a:1))
                                else
                                    echomsg leader . a:msg
                                endif
                            
                                call s:_logRedirect(0)

FUNCTION  <SNR>150_ProcessFile()
Called 2 times
Total time:   0.033629
 Self time:   0.003629

count  total (s)   self (s)
    2   0.000034   0.000015     call s:debug('ProcessFile called [' . a:fname . ']')
                            
    2   0.000208   0.000013     if !s:IsValidFile(a:fname, a:ftype)
                                    call s:debug('Not a valid file, returning')
                                    return
                                endif
                            
    2              0.000011     let typeinfo = s:known_types[a:ftype]
                            
                                " If the file has only been updated preserve the fold states, otherwise
                                " create a new entry
    2   0.000077   0.000045     if s:known_files.has(a:fname) && !empty(s:known_files.get(a:fname)) && s:known_files.get(a:fname).ftype == a:ftype
    2   0.000023   0.000014         let fileinfo = s:known_files.get(a:fname)
    2              0.000006         let typeinfo = fileinfo.typeinfo
    2   0.000482   0.000052         call fileinfo.reset()
    2              0.000002     else
                                    if exists('#TagbarProjects#User')
                                        execute 'doautocmd <nomodeline> TagbarProjects User ' . a:fname
                                        if exists('b:tagbar_type')
                                            let typeinfo = extend(copy(typeinfo), s:TransformUserTypeDef(b:tagbar_type))
                                            call typeinfo.createKinddict()
                                        endif
                                    endif
                                    let fileinfo = s:FileInfo.New(a:fname, a:ftype, typeinfo)
                                endif
                            
    2   0.000173   0.000148     call s:debug('typeinfo for file to process: ' . string(typeinfo))
                            
                                " Use a temporary files for ctags processing instead of the original one.
                                " This allows using Tagbar for files accessed with netrw, and also doesn't
                                " slow down Tagbar for files that sit on slow network drives.
    2              0.000024     let tempfile = tempname()
    2              0.000012     let ext = fnamemodify(fileinfo.fpath, ':e')
    2              0.000004     if ext != ''
    2              0.000007         let tempfile .= '.' . ext
    2              0.000003     endif
                            
    2              0.000275     call writefile(getbufline(fileinfo.bufnr, 1, '$'), tempfile)
    2              0.000021     let fileinfo.mtime = getftime(tempfile)
                            
    2   0.016427   0.000078     let ctags_output = s:ExecuteCtagsOnFile(tempfile, a:fname, typeinfo)
                            
    2              0.000057     call delete(tempfile)
                            
    2              0.000014     if ctags_output == -1
                                    call s:debug('Ctags error when processing file')
                                    " Put an empty entry into known_files so the error message is only
                                    " shown once
                                    call s:known_files.put({}, a:fname)
                                    return
                                elseif ctags_output == ''
                                    call s:debug('Ctags output empty')
                                    " No need to go through the tag processing if there are no tags, and
                                    " preserving the old fold state isn't necessary either
                                    call s:known_files.put(s:FileInfo.New(a:fname, a:ftype, s:known_types[a:ftype]), a:fname)
                                    return
                                endif
                            
    2   0.000076   0.000049     call s:debug('Filetype tag kinds: ' . string(keys(typeinfo.kinddict)))
                            
                                " Parse the ctags output lines
    2   0.000035   0.000014     call s:debug('Parsing ctags output')
    2              0.000083     let rawtaglist = split(ctags_output, '\n\+')
   28              0.000061     for line in rawtaglist
                                    " skip comments
   26              0.000169         if line =~# '^!_TAG_'
                                        continue
                                    endif
                            
   26              0.000206         let parts = split(line, ';"')
   26              0.000088         if len(parts) == 2 " Is a valid tag line
   26   0.010082   0.000344             let taginfo = s:ParseTagline(parts[0], parts[1], typeinfo, fileinfo)
   26              0.000078             if !empty(taginfo)
   26              0.000151                 let fileinfo.fline[taginfo.fields.line] = taginfo
   26              0.000115                 call add(fileinfo.tags, taginfo)
   26              0.000033             endif
   26              0.000027         endif
   26              0.000037     endfor
                            
                                " Process scoped tags
    2              0.000006     let processedtags = []
    2              0.000007     if has_key(typeinfo, 'kind2scope')
                                    call s:debug('Processing scoped tags')
                            
                                    let scopedtags = []
                                    let is_scoped = 'has_key(typeinfo.kind2scope, v:val.fields.kind) || has_key(v:val, "scope")'
                                    let scopedtags += filter(copy(fileinfo.tags), is_scoped)
                                    call filter(fileinfo.tags, '!(' . is_scoped . ')')
                            
                                    call s:AddScopedTags(scopedtags, processedtags, {}, 0, typeinfo, fileinfo, line('$'))
                            
                                    if !empty(scopedtags)
                                        echoerr 'Tagbar: ''scopedtags'' not empty after processing,' 'this should never happen!' 'Please contact the script maintainer with an example.'
                                    endif
                                endif
    2   0.000045   0.000022     call s:debug('Number of top-level tags: ' . len(processedtags))
                            
                                " Create a placeholder tag for the 'kind' header for folding purposes
   14              0.000029     for kind in typeinfo.kinds
                            
   12              0.000280         let curtags = filter(copy(fileinfo.tags), 'v:val.fields.kind ==# kind.short')
   12   0.000263   0.000138         call s:debug('Processing kind: ' . kind.short . ', number of tags: ' . len(curtags))
                            
   12              0.000034         if empty(curtags)
    6              0.000014             continue
                                    endif
                            
    6   0.000362   0.000047         let kindtag          = s:KindheaderTag.New(kind.long)
    6              0.000017         let kindtag.short    = kind.short
    6              0.000023         let kindtag.numtags  = len(curtags)
    6              0.000013         let kindtag.fileinfo = fileinfo
                            
   32              0.000043         for tag in curtags
   26              0.000066             let tag.parent = kindtag
   26              0.000035         endfor
    6              0.000007     endfor
                            
    2              0.000006     if !empty(processedtags)
                                    call extend(fileinfo.tags, processedtags)
                                endif
                            
                                " Clear old folding information from previous file version to prevent leaks
    2   0.000040   0.000015     call fileinfo.clearOldFolds()
                            
                                " Sort the tags
    2              0.000008     let s:compare_typeinfo = typeinfo
    2   0.002648   0.000013     call fileinfo.sortTags()
                            
    2   0.000052   0.000020     call s:known_files.put(fileinfo)

FUNCTION  gitgutter#sign#remove_signs()
Called 2 times
Total time:   0.000085
 Self time:   0.000081

count  total (s)   self (s)
    2   0.000015   0.000011   let bufnr = gitgutter#utility#bufnr()
    2              0.000012   if a:all_signs && s:supports_star && empty(getbufvar(bufnr, 'gitgutter_other_signs'))
    2              0.000011     let dummy_sign_present = getbufvar(bufnr, 'gitgutter_dummy_sign')
    2              0.000017     execute "sign unplace * buffer=" . bufnr
    2              0.000005     if dummy_sign_present
                                  execute "sign place" s:dummy_sign_id "line=" . 9999 "name=GitGutterDummy buffer=" . bufnr
                                endif
    2              0.000002   else
                                for id in a:sign_ids
                                  execute "sign unplace" id
                                endfor
                              endif

FUNCTION  <SNR>104_sync_active_winnr()
Called 3 times
Total time:   0.000037
 Self time:   0.000037

count  total (s)   self (s)
    3              0.000024   if exists('#airline') && winnr() != s:active_winnr
                                call airline#update_statusline()
                              endif

FUNCTION  <SNR>112_check_mixed_indent()
Called 3 times
Total time:   0.000729
 Self time:   0.000729

count  total (s)   self (s)
    3              0.000007   if s:indent_algo == 1
                                " [<tab>]<space><tab>
                                " spaces before or between tabs are not allowed
                                let t_s_t = '(^\t* +\t\s*\S)'
                                " <tab>(<space> x count)
                                " count of spaces at the end of tabs should be less than tabstop value
                                let t_l_s = '(^\t+ {' . &ts . ',}' . '\S)'
                                return search('\v' . t_s_t . '|' . t_l_s, 'nw')
                              elseif s:indent_algo == 2
                                return search('\v(^\t* +\t\s*\S)', 'nw')
                              else
    3              0.000681     return search('\v(^\t+ +)|(^ +\t+)', 'nw')
                              endif

FUNCTION  airline#statusline()
Called 13 times
Total time:   0.000344
 Self time:   0.000344

count  total (s)   self (s)
   13              0.000170   if has_key(s:contexts, a:winnr)
   13              0.000133     return '%{airline#check_mode('.a:winnr.')}'.s:contexts[a:winnr].line
                              endif
                            
                              " in rare circumstances this happens...see #276
                              return ''

FUNCTION  airline#check_mode()
Called 13 times
Total time:   0.001580
 Self time:   0.001580

count  total (s)   self (s)
   13              0.000077   let context = s:contexts[a:winnr]
                            
   13              0.000060   if get(w:, 'airline_active', 1)
   13              0.000056     let l:m = mode()
   13              0.000033     if l:m ==# "i"
                                  let l:mode = ['insert']
                                elseif l:m ==# "R"
                                  let l:mode = ['replace']
                                elseif l:m =~# '\v(v|V||s|S|)'
                                  let l:mode = ['visual']
                                elseif l:m ==# "t"
                                  let l:mode = ['terminal']
                                else
   13              0.000036       let l:mode = ['normal']
   13              0.000014     endif
   13              0.000082     let w:airline_current_mode = get(g:airline_mode_map, l:m, l:m)
   13              0.000015   else
                                let l:mode = ['inactive']
                                let w:airline_current_mode = get(g:airline_mode_map, '__')
                              endif
                            
   13              0.000058   if g:airline_detect_modified && &modified
                                call add(l:mode, 'modified')
                              endif
                            
   13              0.000034   if g:airline_detect_paste && &paste
                                call add(l:mode, 'paste')
                              endif
                            
   13              0.000074   if g:airline_detect_crypt && exists("+key") && !empty(&key)
                                call add(l:mode, 'crypt')
                              endif
                            
   13              0.000036   if g:airline_detect_spell && &spell
                                call add(l:mode, 'spell')
                              endif
                            
   13              0.000026   if &readonly || ! &modifiable
                                call add(l:mode, 'readonly')
                              endif
                            
   13              0.000066   let mode_string = join(l:mode)
   13              0.000064   if get(w:, 'airline_lastmode', '') != mode_string
                                call airline#highlighter#highlight_modified_inactive(context.bufnr)
                                call airline#highlighter#highlight(l:mode, context.bufnr)
                                let w:airline_lastmode = mode_string
                              endif
                            
   13              0.000020   return ''

FUNCTION  <SNR>147_channel_id()
Called 4 times
Total time:   0.000043
 Self time:   0.000043

count  total (s)   self (s)
    4              0.000037   return ch_info(a:channel)['id']

FUNCTION  airline#util#append()
Called 65 times
Total time:   0.000936
 Self time:   0.000936

count  total (s)   self (s)
   65              0.000205   if a:minwidth > 0 && winwidth(0) < a:minwidth
                                return ''
                              endif
   65              0.000268   let prefix = s:spc == "\ua0" ? s:spc : s:spc.s:spc
   65              0.000244   return empty(a:text) ? '' : prefix.g:airline_left_alt_sep.s:spc.a:text

FUNCTION  <SNR>150_IsValidFile()
Called 5 times
Total time:   0.000473
 Self time:   0.000425

count  total (s)   self (s)
    5   0.000084   0.000036     call s:debug('Checking if file is valid [' . a:fname . ']')
                            
    5              0.000016     if a:fname == '' || a:ftype == ''
                                    call s:debug('Empty filename or type')
                                    return 0
                                endif
                            
    5              0.000063     if !filereadable(a:fname) && getbufvar(a:fname, 'netrw_tmpfile') == ''
                                    call s:debug('File not readable')
                                    return 0
                                endif
                            
    5              0.000087     if getbufvar(a:fname, 'tagbar_ignore') == 1
                                    call s:debug('File is marked as ignored')
                                    return 0
                                endif
                            
    5              0.000009     if &previewwindow
                                    call s:debug('In preview window')
                                    return 0
                                endif
                            
    5              0.000023     if !has_key(s:known_types, a:ftype)
                                    if exists('g:tagbar_type_' . a:ftype)
                                        " Filetype definition must have been specified in an 'ftplugin'
                                        " file, so load it now
                                        call s:LoadUserTypeDefs(a:ftype)
                                    else
                                        call s:debug('Unsupported filetype: ' . a:ftype)
                                        return 0
                                    endif
                                endif
                            
    5              0.000007     return 1

FUNCTION  <SNR>66__is_quitting()
Called 3 times
Total time:   0.000057
 Self time:   0.000057

count  total (s)   self (s)
    3              0.000006     let quitting = 0
    3              0.000010     if exists('w:syntastic_wid')
                                    let key = a:buf . '_' . getbufvar(a:buf, 'changetick') . '_' . w:syntastic_wid
                                    let idx = index(s:_quit_pre, key)
                                    if idx >= 0
                                        call remove(s:_quit_pre, idx)
                                        let quitting = 1
                                    endif
                                endif
                            
    3              0.000004     return quitting

FUNCTION  gitgutter#sign#update_signs()
Called 2 times
Total time:   0.000641
 Self time:   0.000137

count  total (s)   self (s)
    2   0.000244   0.000016   call gitgutter#sign#find_current_signs()
                            
    2              0.000013   let new_gitgutter_signs_line_numbers = map(copy(a:modified_lines), 'v:val[0]')
    2   0.000113   0.000026   let obsolete_signs = gitgutter#sign#obsolete_gitgutter_signs_to_remove(new_gitgutter_signs_line_numbers)
                            
    2              0.000011   let flicker_possible = s:remove_all_old_signs && !empty(a:modified_lines)
    2              0.000003   if flicker_possible
                                call gitgutter#sign#add_dummy_sign()
                              endif
                            
    2   0.000103   0.000018   call gitgutter#sign#remove_signs(obsolete_signs, s:remove_all_old_signs)
    2   0.000123   0.000019   call gitgutter#sign#upsert_new_gitgutter_signs(a:modified_lines)
                            
    2              0.000004   if flicker_possible
                                call gitgutter#sign#remove_dummy_sign(0)
                              endif

FUNCTION  syntastic#util#shescape()
Called 4 times
Total time:   0.000049
 Self time:   0.000049

count  total (s)   self (s)
    4              0.000046     return a:string =~# '\m^[A-Za-z0-9_/.-]\+$' ? a:string : shellescape(a:string)

FUNCTION  gitgutter#sign#find_current_signs()
Called 2 times
Total time:   0.000228
 Self time:   0.000222

count  total (s)   self (s)
    2   0.000016   0.000010   let bufnr = gitgutter#utility#bufnr()
    2              0.000006   let gitgutter_signs = {}  " <line_number (string)>: {'id': <id (number)>, 'name': <name (string)>}
    2              0.000006   let other_signs = []      " [<line_number (number),...]
    2              0.000005   let dummy_sign_placed = 0
                            
    2              0.000010   redir => signs
    2              0.000029     silent execute "sign place buffer=" . bufnr
    2              0.000007   redir END
                            
    2              0.000025   for sign_line in filter(split(signs, '\n')[2:], 'v:val =~# "="')
                                " Typical sign line:  line=88 id=1234 name=GitGutterLineAdded
                                " We assume splitting is faster than a regexp.
                                let components  = split(sign_line)
                                let name        = split(components[2], '=')[1]
                                if name =~# 'GitGutterDummy'
                                  let dummy_sign_placed = 1
                                else
                                  let line_number = str2nr(split(components[0], '=')[1])
                                  if name =~# 'GitGutter'
                                    let id = str2nr(split(components[1], '=')[1])
                                    " Remove orphaned signs (signs placed on lines which have been deleted).
                                    " (When a line is deleted its sign lingers.  Subsequent lines' signs'
                                    " line numbers are decremented appropriately.)
                                    if has_key(gitgutter_signs, line_number)
                                      execute "sign unplace" gitgutter_signs[line_number].id
                                    endif
                                    let gitgutter_signs[line_number] = {'id': id, 'name': name}
                                  else
                                    call add(other_signs, line_number)
                                  endif
                                end
                              endfor
                            
    2              0.000013   call setbufvar(bufnr, 'gitgutter_dummy_sign', dummy_sign_placed)
    2              0.000012   call setbufvar(bufnr, 'gitgutter_gitgutter_signs', gitgutter_signs)
    2              0.000011   call setbufvar(bufnr, 'gitgutter_other_signs', other_signs)

FUNCTION  airline#parts#filetype()
Called 13 times
Total time:   0.000095
 Self time:   0.000095

count  total (s)   self (s)
   13              0.000082   return winwidth(0) < 100 && strlen(&filetype) > 3 ? matchstr(&filetype, '...'). (&encoding is? 'utf-8' ? '…' : '>') : &filetype

FUNCTION  airline#parts#iminsert()
Called 13 times
Total time:   0.000113
 Self time:   0.000113

count  total (s)   self (s)
   13              0.000041   if g:airline_detect_iminsert && &iminsert && exists('b:keymap_name')
                                return toupper(b:keymap_name)
                              endif
   13              0.000014   return ''

FUNCTION  gitgutter#utility#use_known_shell()
Called 3 times
Total time:   0.000104
 Self time:   0.000104

count  total (s)   self (s)
    3              0.000012   if has('unix')
    3              0.000015     let s:shell = &shell
    3              0.000010     let s:shellcmdflag = &shellcmdflag
    3              0.000007     let s:shellredir = &shellredir
    3              0.000018     let &shell = 'sh'
    3              0.000018     set shellcmdflag=-c
    3              0.000010     set shellredir=>%s\ 2>&1
    3              0.000005   endif

FUNCTION  <SNR>86_OnCommand()
Called 5 times
Total time:   0.000198
 Self time:   0.000198

count  total (s)   self (s)
    5              0.000080     if getcmdtype() == "/" || getcmdtype() == "?"
                                    call s:Stop()
                                    return "\<CR>:call <SNR>".s:SID()."_Start()\<CR>"
                                else
    5              0.000023         return "\<CR>"
                                endif

FUNCTION  gitgutter#process_buffer()
Called 3 times
Total time:   0.003486
 Self time:   0.000381

count  total (s)   self (s)
    3   0.000129   0.000025   call gitgutter#utility#use_known_shell()
                            
    3   0.000086   0.000025   call gitgutter#utility#set_buffer(a:bufnr)
    3   0.000258   0.000019   if gitgutter#utility#is_active()
    3              0.000009     if g:gitgutter_sign_column_always
                                  call gitgutter#sign#add_dummy_sign()
                                endif
    3              0.000004     try
    3   0.000023   0.000016       if !a:realtime || gitgutter#utility#has_fresh_changes()
    2   0.002637   0.000072         let diff = gitgutter#diff#run_diff(a:realtime || gitgutter#utility#has_unsaved_changes(), 0)
    2              0.000005         if diff != 'async'
                                      call gitgutter#handle_diff(diff)
                                    endif
    2              0.000002       endif
    3              0.000006     catch /diff failed/
                                  call gitgutter#debug#log('diff failed')
                                  call gitgutter#hunk#reset()
                                endtry
    3   0.000136   0.000092     execute "silent doautocmd" s:nomodeline "User GitGutter"
    3              0.000004   else
                                call gitgutter#hunk#reset()
                              endif
                            
    3   0.000114   0.000029   call gitgutter#utility#restore_shell()

FUNCTION  SyntaxCheckers_php_php_GetLocList()
Called 1 time
Total time:   0.030915
 Self time:   0.000041

count  total (s)   self (s)
    1   0.000471   0.000017     let makeprg = self.makeprgBuild({ 'args': '-d error_reporting=E_ALL', 'args_after': '-l -d display_errors=1 -d log_errors=0 -d xdebug.cli_color=0' })
                            
    1              0.000006     let errorformat = '%-GNo syntax errors detected in%.%#,'. 'Parse error: %#syntax %trror\, %m in %f on line %l,'. 'Parse %trror: %m in %f on line %l,'. 'Fatal %trror: %m in %f on line %l,'. '%-G\s%#,'. '%-GErrors parsing %.%#'
                            
    1   0.030435   0.000015     return SyntasticMake({ 'makeprg': makeprg, 'errorformat': errorformat, 'postprocess': ['guards'] })

FUNCTION  <SNR>150_AutoUpdate()
Called 3 times
Total time:   0.035736
 Self time:   0.001006

count  total (s)   self (s)
    3   0.000078   0.000036     call s:debug('AutoUpdate called [' . a:fname . ']')
                            
                                " This file is being loaded due to a quickfix command like vimgrep, so
                                " don't process it
    3              0.000013     if exists('s:tagbar_qf_active')
                                    return
                                elseif exists('s:window_opening')
                                    " This can happen if another plugin causes the active window to change
                                    " with an autocmd during the initial Tagbar window creation. In that
                                    " case InitWindow() hasn't had a chance to run yet and things can
                                    " break. MiniBufExplorer does this, for example. Completely disabling
                                    " autocmds at that point is also not ideal since for example
                                    " statusline plugins won't be able to update.
                                    call s:debug('Still opening window, stopping processing')
                                    return
                                endif
                            
                                " Get the filetype of the file we're about to process
    3              0.000064     let bufnr = bufnr(a:fname)
    3              0.000016     let ftype = getbufvar(bufnr, '&filetype')
                            
                                " Don't do anything if we're in the tagbar window
    3              0.000006     if ftype == 'tagbar'
                                    call s:debug('In Tagbar window, stopping processing')
                                    return
                                endif
                            
                                " Only consider the main filetype in cases like 'python.django'
    3              0.000027     let sftype = get(split(ftype, '\.'), 0, '')
    3   0.000055   0.000026     call s:debug("Vim filetype: '" . ftype . "', " . "sanitized filetype: '" . sftype . "'")
                            
                                " Don't do anything if the file isn't supported
    3   0.000304   0.000026     if !s:IsValidFile(a:fname, sftype)
                                    call s:debug('Not a valid file, stopping processing')
                                    let s:nearby_disabled = 1
                                    return
                                endif
                            
    3              0.000007     let updated = 0
                            
                                " Process the file if it's unknown or the information is outdated.
                                " Testing the mtime of the file is necessary in case it got changed
                                " outside of Vim, for example by checking out a different version from a
                                " VCS.
    3   0.000064   0.000027     if s:known_files.has(a:fname)
    3   0.000088   0.000053         let curfile = s:known_files.get(a:fname)
                                    " if a:force || getbufvar(curfile.bufnr, '&modified') ||
    3              0.000027         if a:force || empty(curfile) || curfile.ftype != sftype || (filereadable(a:fname) && getftime(a:fname) > curfile.mtime)
    2   0.000038   0.000017             call s:debug('File data outdated, updating [' . a:fname . ']')
    2   0.033667   0.000038             call s:ProcessFile(a:fname, sftype)
    2              0.000006             let updated = 1
    2              0.000001         else
    1   0.000013   0.000006             call s:debug('File data seems up to date [' . a:fname . ']')
    1              0.000001         endif
    3              0.000007     elseif !s:known_files.has(a:fname)
                                    call s:debug('New file, processing [' . a:fname . ']')
                                    call s:ProcessFile(a:fname, sftype)
                                    let updated = 1
                                endif
                            
    3   0.000040   0.000024     let fileinfo = s:known_files.get(a:fname)
                            
                                " If we don't have an entry for the file by now something must have gone
                                " wrong, so don't change the tagbar content
    3              0.000020     if empty(fileinfo)
                                    call s:debug('fileinfo empty after processing [' . a:fname . ']')
                                    return
                                endif
                            
                                " Display the tagbar content if the tags have been updated or a different
                                " file is being displayed
    3              0.000203     if bufwinnr('__Tagbar__') != -1 && !s:paused && (s:new_window || updated || (!empty(s:known_files.getCurrent(0)) && a:fname != s:known_files.getCurrent(0).fpath))
                                    call s:RenderContent(fileinfo)
                                endif
                            
                                " Call setCurrent after rendering so RenderContent can check whether the
                                " same file is being redisplayed
    3              0.000007     if !empty(fileinfo)
    3   0.000051   0.000022         call s:debug('Setting current file [' . a:fname . ']')
    3   0.000029   0.000018         call s:known_files.setCurrent(fileinfo)
    3              0.000008         let s:nearby_disabled = 0
    3              0.000003     endif
                            
    3   0.000420   0.000029     call s:HighlightTag(0)
    3   0.000207   0.000032     call s:SetStatusLine()
    3   0.000048   0.000018     call s:debug('AutoUpdate finished successfully')

FUNCTION  300()
Called 16 times
Total time:   0.000822
 Self time:   0.000822

count  total (s)   self (s)
   16              0.000271     let newObj = copy(self)
                            
   16              0.000099     let llist = filter(copy(a:rawLoclist), 'v:val["valid"] == 1')
                            
   16              0.000042     for e in llist
                                    if get(e, 'type', '') ==# ''
                                        let e['type'] = 'E'
                                    endif
                                endfor
                            
   16              0.000046     let newObj._rawLoclist = llist
   16              0.000032     let newObj._name = ''
   16              0.000047     let newObj._owner = bufnr('')
   16              0.000046     let newObj._sorted = 0
   16              0.000047     let newObj._columns = g:syntastic_cursor_columns
                            
   16              0.000022     return newObj

FUNCTION  301()
Called 16 times
Total time:   0.001265
 Self time:   0.000521

count  total (s)   self (s)
   16              0.000093     let buf = a:0 ? a:1 : bufnr('')
   16   0.000273   0.000134     let loclist = syntastic#util#getbufvar(buf, 'syntastic_loclist', {})
   16              0.000089     if type(loclist) != type({}) || empty(loclist)
   12              0.000026         unlet! loclist
   12   0.000688   0.000083         let loclist = g:SyntasticLoclist.New([])
   12              0.000011     endif
   16              0.000023     return loclist

FUNCTION  304()
Called 14 times
Total time:   0.000050
 Self time:   0.000050

count  total (s)   self (s)
   14              0.000040     return empty(self._rawLoclist)

FUNCTION  306()
Called 2 times
Total time:   0.000007
 Self time:   0.000007

count  total (s)   self (s)
    2              0.000006     return copy(self._rawLoclist)

FUNCTION  308()
Called 3 times
Total time:   0.000162
 Self time:   0.000042

count  total (s)   self (s)
    3   0.000157   0.000037     return syntastic#util#unique(map(copy(self._rawLoclist), 'str2nr(v:val["bufnr"])') + [self._owner])

FUNCTION  airline#extensions#tabline#buflist#list()
Called 6 times
Total time:   0.000035
 Self time:   0.000035

count  total (s)   self (s)
    6              0.000018   if exists('s:current_buffer_list')
    6              0.000008     return s:current_buffer_list
                              endif
                            
                              let list = (exists('g:did_bufmru') && g:did_bufmru) ? BufMRUList() : range(1, bufnr("$"))
                            
                              let buffers = []
                              " If this is too slow, we can switch to a different algorithm.
                              " Basically branch 535 already does it, but since it relies on
                              " BufAdd autocommand, I'd like to avoid this if possible.
                              for nr in list
                                if buflisted(nr)
                                  " Do not add to the bufferlist, if either
                                  " 1) buffername matches exclude pattern
                                  " 2) buffer is a quickfix buffer
                                  " 3) exclude preview windows (if 'bufhidden' == wipe
                                  "    and 'buftype' == nofile
                                  if (!empty(s:excludes) && match(bufname(nr), join(s:excludes, '\|')) > -1) || (getbufvar(nr, 'current_syntax') == 'qf') ||  (s:exclude_preview && getbufvar(nr, '&bufhidden') == 'wipe'  && getbufvar(nr, '&buftype') == 'nofile')
                                    continue
                                  endif
                                  call add(buffers, nr)
                                endif
                              endfor
                            
                              let s:current_buffer_list = buffers
                              return buffers

FUNCTION  syntastic#util#stamp()
Called 5 times
Total time:   0.000112
 Self time:   0.000112

count  total (s)   self (s)
    5              0.000107     return split( split(reltimestr(reltime(g:_SYNTASTIC_START)))[0], '\.' )

FUNCTION  gitgutter#sign#upsert_new_gitgutter_signs()
Called 2 times
Total time:   0.000104
 Self time:   0.000099

count  total (s)   self (s)
    2   0.000016   0.000011   let bufnr = gitgutter#utility#bufnr()
    2              0.000010   let other_signs         = getbufvar(bufnr, 'gitgutter_other_signs')
    2              0.000010   let old_gitgutter_signs = getbufvar(bufnr, 'gitgutter_gitgutter_signs')
                            
    2              0.000005   for line in a:modified_lines
                                let line_number = line[0]  " <number>
                                if index(other_signs, line_number) == -1  " don't clobber others' signs
                                  let name = gitgutter#utility#highlight_name_for_change(line[1])
                                  if !has_key(old_gitgutter_signs, line_number)  " insert
                                    let id = gitgutter#sign#next_sign_id()
                                    execute "sign place" id "line=" . line_number "name=" . name "buffer=" . bufnr
                                  else  " update if sign has changed
                                    let old_sign = old_gitgutter_signs[line_number]
                                    if old_sign.name !=# name
                                      execute "sign place" old_sign.id "name=" . name "buffer=" . bufnr
                                    end
                                  endif
                                endif
                              endfor
                              " At this point b:gitgutter_gitgutter_signs is out of date.

FUNCTION  gitgutter#utility#command_in_directory_of_file()
Called 2 times
Total time:   0.000061
 Self time:   0.000026

count  total (s)   self (s)
    2   0.000058   0.000023   return 'cd '.gitgutter#utility#shellescape(gitgutter#utility#directory_of_file()).' && '.a:cmd

FUNCTION  315()
Called 1 time
Total time:   0.000005
 Self time:   0.000005

count  total (s)   self (s)
    1              0.000005     let self._owner = type(a:buffer) == type(0) ? a:buffer : str2nr(a:buffer)

FUNCTION  316()
Called 1 time
Total time:   0.000143
 Self time:   0.000038

count  total (s)   self (s)
    1   0.000038   0.000009     let self._stamp = syntastic#util#stamp()
    2   0.000087   0.000011     for buf in self.getBuffers()
    1              0.000010         call setbufvar(buf, 'syntastic_loclist', self)
    1              0.000002     endfor

FUNCTION  317()
Called 2 times
Total time:   0.000116
 Self time:   0.000030

count  total (s)   self (s)
    4   0.000098   0.000012     for buf in self.getBuffers()
    2              0.000011         call setbufvar(buf, 'syntastic_loclist', {})
    2              0.000002     endfor

FUNCTION  329()
Called 2 times
Total time:   0.000080
 Self time:   0.000052

count  total (s)   self (s)
    2              0.000018     let fts = split(a:filetype, '\m\.')
                            
    2   0.000020   0.000013     if self.isPassive()
    1   0.000016   0.000006         return self._isOneFiletypeActive(fts)
                                else
    1   0.000019   0.000008         return self._noFiletypesArePassive(fts)
                                endif

FUNCTION  305()
Called 4 times
Total time:   0.000144
 Self time:   0.000061

count  total (s)   self (s)
    4              0.000014     if !exists('self._stamp')
    1              0.000002         let self._stamp = []
    1              0.000001         return 0
                                endif
    3   0.000109   0.000026     return syntastic#util#compareLexi(self._stamp, a:stamp) > 0

FUNCTION  386()
Called 26 times
Total time:   0.001037
 Self time:   0.000907

count  total (s)   self (s)
   26              0.000087     let fileinfo = self.fileinfo
                            
   26   0.000425   0.000295     if s:known_files.has(fileinfo.fpath) && has_key(fileinfo, '_tagfolds_old') && has_key(fileinfo._tagfolds_old[self.fields.kind], self.fullpath)
                                    " The file has been updated and the tag was there before, so copy its
                                    " old fold state
   26              0.000175         let fileinfo.tagfolds[self.fields.kind][self.fullpath] = fileinfo._tagfolds_old[self.fields.kind][self.fullpath]
   26              0.000064     elseif self.depth >= fileinfo.foldlevel
                                    let fileinfo.tagfolds[self.fields.kind][self.fullpath] = 1
                                else
                                    let fileinfo.tagfolds[self.fields.kind][self.fullpath] = fileinfo.kindfolds[self.fields.kind]
                                endif

FUNCTION  330()
Called 2 times
Total time:   0.000123
 Self time:   0.000043

count  total (s)   self (s)
    2              0.000010     let local_mode = get(b:, 'syntastic_mode', '')
    2              0.000008     if local_mode ==# 'active' || local_mode ==# 'passive'
                                    return local_mode ==# 'active'
                                endif
                            
    2   0.000096   0.000016     return self.allowsAutoChecking(&filetype)

FUNCTION  331()
Called 2 times
Total time:   0.000007
 Self time:   0.000007

count  total (s)   self (s)
    2              0.000006     return self._mode ==# 'passive'

FUNCTION  332()
Called 1 time
Total time:   0.000063
 Self time:   0.000032

count  total (s)   self (s)
    1   0.000036   0.000005     call self.synch()
                            
    1              0.000013     if self._mode ==# 'active'
                                    let self._mode = 'passive'
                                else
    1              0.000001         let self._mode = 'active'
    1              0.000001     endif
                            
                                "XXX Changing a global variable.  Tsk, tsk...
    1              0.000003     if !exists('g:syntastic_mode_map')
                                    let g:syntastic_mode_map = {}
                                endif
    1              0.000003     let g:syntastic_mode_map['mode'] = self._mode

FUNCTION  333()
Called 1 time
Total time:   0.000027
 Self time:   0.000027

count  total (s)   self (s)
    1              0.000027     echo 'Syntastic: ' . self._mode . ' mode enabled'

FUNCTION  335()
Called 1 time
Total time:   0.000010
 Self time:   0.000010

count  total (s)   self (s)
    1              0.000010     return !empty(filter(copy(a:filetypes), 'index(self._activeFiletypes, v:val) != -1'))

FUNCTION  336()
Called 1 time
Total time:   0.000011
 Self time:   0.000011

count  total (s)   self (s)
    1              0.000011     return empty(filter(copy(a:filetypes), 'index(self._passiveFiletypes, v:val) != -1'))

FUNCTION  338()
Called 2 times
Total time:   0.002353
 Self time:   0.000788

count  total (s)   self (s)
    2   0.000097   0.000031     if !syntastic#util#bufIsActive(bufnr('')) || (!a:loclist.isEmpty() && !a:loclist.isNewerThan([]))
                                    " loclist not fully constructed yet
                                    return
                                endif
                            
    2   0.000034   0.000014     call syntastic#log#debug(g:_SYNTASTIC_DEBUG_NOTIFICATIONS, 'notifiers: refresh')
   12              0.000024     for type in self._enabled_types
   10              0.000135         let class = substitute(type, '\m.*', 'Syntastic\u&Notifier', '')
   10   0.000307   0.000111         if !has_key(g:{class}, 'enabled') || self._notifier[type].enabled()
   10              0.000040             if index(s:_PERSISTENT_NOTIFIERS, type) > -1
                                            " refresh only if loclist has changed since last call
    4              0.000024                 if !exists('b:syntastic_private_' . type . '_stamp')
                                                let b:syntastic_private_{type}_stamp = []
                                            endif
    4   0.000191   0.000043                 if a:loclist.isNewerThan(b:syntastic_private_{type}_stamp) || a:loclist.isEmpty()
    4   0.000487   0.000031                     call self._notifier[type].refresh(a:loclist)
    4   0.000123   0.000040                     let b:syntastic_private_{type}_stamp = syntastic#util#stamp()
    4              0.000006                 endif
    4              0.000004             else
    6   0.000643   0.000047                 call self._notifier[type].refresh(a:loclist)
    6              0.000007             endif
   10              0.000008         endif
   10              0.000011     endfor

FUNCTION  <SNR>34_record()
Called 2 times
Total time:   0.000427
 Self time:   0.000127

count  total (s)   self (s)
    2              0.000017 	if s:locked | retu | en
    2              0.000010 	let bufnr = a:bufnr + 0
    2              0.000010 	let bufname = bufname(bufnr)
    2              0.000008 	if bufnr > 0 && !empty(bufname)
    2              0.000024 		cal filter(s:mrbs, 'v:val != bufnr')
    2              0.000010 		cal insert(s:mrbs, bufnr)
    2   0.000338   0.000038 		cal s:addtomrufs(bufname)
    2              0.000002 	en

FUNCTION  airline#extensions#tabline#get_buffer_name()
Called 6 times
Total time:   0.000566
 Self time:   0.000078

count  total (s)   self (s)
    6   0.000038   0.000027   let buffers = a:0 ? a:1 : airline#extensions#tabline#buflist#list()
    6   0.000525   0.000048   return airline#extensions#tabline#formatters#{s:formatter}#format(a:nr, buffers)

FUNCTION  343()
Called 1 time
Total time:   0.000106
 Self time:   0.000056

count  total (s)   self (s)
    1   0.000026   0.000009     let ft = s:_normalise_filetype(a:ftalias)
    1   0.000011   0.000006     call self._loadCheckersFor(ft, 0)
                            
    1              0.000003     let checkers_map = self._checkerMap[ft]
    1              0.000002     if empty(checkers_map)
                                    return []
                                endif
                            
    1   0.000019   0.000006     call self._checkDeprecation(ft)
                            
    1              0.000012     let names = !empty(a:hints_list) ? syntastic#util#unique(a:hints_list) : exists('b:syntastic_checkers') ? b:syntastic_checkers : exists('g:syntastic_' . ft . '_checkers') ? g:syntastic_{ft}_checkers : get(s:_DEFAULT_CHECKERS, ft, 0)
                            
    1   0.000026   0.000011     return type(names) == type([]) ? self._filterCheckersByName(checkers_map, names) : [checkers_map[keys(checkers_map)[0]]]

FUNCTION  <SNR>147_job_buffer()
Called 2 times
Total time:   0.000013
 Self time:   0.000013

count  total (s)   self (s)
    2              0.000012   return s:jobs[a:id].buffer

FUNCTION  gitgutter#diff#parse_diff()
Called 2 times
Total time:   0.000063
 Self time:   0.000063

count  total (s)   self (s)
    2              0.000007   let hunks = []
    2              0.000029   for line in split(a:diff, '\n')
                                let hunk_info = gitgutter#diff#parse_hunk(line)
                                if len(hunk_info) == 4
                                  call add(hunks, hunk_info)
                                endif
                              endfor
    2              0.000003   return hunks

FUNCTION  gitgutter#utility#has_fresh_changes()
Called 1 time
Total time:   0.000007
 Self time:   0.000007

count  total (s)   self (s)
    1              0.000006   return getbufvar(s:bufnr, 'changedtick') != getbufvar(s:bufnr, 'gitgutter_last_tick')

FUNCTION  gitgutter#diff#process_hunks()
Called 2 times
Total time:   0.000067
 Self time:   0.000042

count  total (s)   self (s)
    2   0.000038   0.000013   call gitgutter#hunk#reset()
    2              0.000005   let modified_lines = []
    2              0.000005   for hunk in a:hunks
                                call extend(modified_lines, gitgutter#diff#process_hunk(hunk))
                              endfor
    2              0.000003   return modified_lines

FUNCTION  350()
Called 1 time
Total time:   0.000015
 Self time:   0.000015

count  total (s)   self (s)
    1              0.000015     return filter( map(copy(a:list), 'get(a:checkers_map, v:val, {})'), '!empty(v:val)' )

FUNCTION  351()
Called 1 time
Total time:   0.000005
 Self time:   0.000005

count  total (s)   self (s)
    1              0.000004     if !a:force && has_key(self._checkerMap, a:filetype)
    1              0.000001         return
                                endif
                            
                                execute 'runtime! syntax_checkers/' . a:filetype . '/*.vim'
                            
                                if !has_key(self._checkerMap, a:filetype)
                                    let self._checkerMap[a:filetype] = {}
                                endif

FUNCTION  352()
Called 1 time
Total time:   0.000013
 Self time:   0.000013

count  total (s)   self (s)
    1              0.000007     if exists('g:syntastic_' . a:filetype . '_checker') && !exists('g:syntastic_' . a:filetype . '_checkers') && type(g:syntastic_{a:filetype}_checker) == type('')
                            
                                    let g:syntastic_{a:filetype}_checkers = [g:syntastic_{a:filetype}_checker]
                                    call syntastic#log#oneTimeWarn('variable g:syntastic_' . a:filetype . '_checker is deprecated')
                                endif

FUNCTION  354()
Called 4 times
Total time:   0.000124
 Self time:   0.000056

count  total (s)   self (s)
    4   0.000123   0.000055     return has('signs') && syntastic#util#var('enable_signs')

FUNCTION  355()
Called 2 times
Total time:   0.000365
 Self time:   0.000102

count  total (s)   self (s)
    2   0.000035   0.000012     call syntastic#log#debug(g:_SYNTASTIC_DEBUG_NOTIFICATIONS, 'signs: refresh')
                            
    2   0.000039   0.000015     let old_signs = copy(self._bufSignIds())
    2   0.000070   0.000009     if self.enabled()
    2              0.000004         if !s:setup_done
                                        call self._setup()
                                        let s:setup_done = 1
                                        lockvar s:setup_done
                                    endif
                            
    2   0.000132   0.000015         call self._signErrors(a:loclist)
    2              0.000003     endif
    2   0.000050   0.000012     call self._removeSigns(old_signs)

FUNCTION  357()
Called 2 times
Total time:   0.000117
 Self time:   0.000110

count  total (s)   self (s)
    2              0.000006     let loclist = a:loclist
    2   0.000016   0.000009     if !loclist.isEmpty()
                            
                                    let buf = bufnr('')
                                    if !bufloaded(buf)
                                        " signs can be placed only in loaded buffers
                                        return
                                    endif
                            
                                    " errors come first, so that they are not masked by warnings
                                    let issues = copy(loclist.errors())
                                    call extend(issues, loclist.warnings())
                                    call filter(issues, 'v:val["bufnr"] == buf')
                                    let seen = {}
                            
                                    for i in issues
                                        if i['lnum'] > 0 && !has_key(seen, i['lnum'])
                                            let seen[i['lnum']] = 1
                            
                                            let sign_severity = i['type'] ==? 'W' ? 'Warning' : 'Error'
                                            let sign_subtype = get(i, 'subtype', '')
                                            let sign_type = 'Syntastic' . sign_subtype . sign_severity
                            
                                            execute 'sign place ' . s:next_sign_id . ' line=' . i['lnum'] . ' name=' . sign_type . ' buffer=' . i['bufnr']
                                            call add(self._bufSignIds(), s:next_sign_id)
                                            let s:next_sign_id += 1
                                        endif
                                    endfor
                                endif

FUNCTION  358()
Called 2 times
Total time:   0.000038
 Self time:   0.000038

count  total (s)   self (s)
    2              0.000009     if has('signs')
    2              0.000010         for s in reverse(copy(a:ids))
                                        execute 'sign unplace ' . s
                                        call remove(self._bufSignIds(), index(self._bufSignIds(), s))
                                    endfor
    2              0.000002     endif

FUNCTION  359()
Called 2 times
Total time:   0.000024
 Self time:   0.000024

count  total (s)   self (s)
    2              0.000011     if !exists('b:syntastic_private_sign_ids')
                                    let b:syntastic_private_sign_ids = []
                                endif
    2              0.000005     return b:syntastic_private_sign_ids

FUNCTION  gitgutter#utility#filename()
Called 2 times
Total time:   0.000011
 Self time:   0.000011

count  total (s)   self (s)
    2              0.000007   return fnamemodify(s:file, ':t')

FUNCTION  <SNR>66_ClearCache()
Called 2 times
Total time:   0.000867
 Self time:   0.000039

count  total (s)   self (s)
    2   0.000166   0.000014     let loclist = g:SyntasticLoclist.current(a:buf)
    2   0.000573   0.000013     call s:notifiers.reset(loclist)
    2   0.000127   0.000011     call loclist.destroy()

FUNCTION  airline#extensions#tabline#tabs#get()
Called 2 times
Total time:   0.000455
 Self time:   0.000059

count  total (s)   self (s)
    2              0.000009   let curbuf = bufnr('%')
    2              0.000006   let curtab = tabpagenr()
    2   0.000413   0.000017   call airline#extensions#tabline#tabs#map_keys()
    2              0.000007   if curbuf == s:current_bufnr && curtab == s:current_tabnr
    2              0.000013     if !g:airline_detect_modified || getbufvar(curbuf, '&modified') == s:current_modified
    2              0.000006       return s:current_tabline
                                endif
                              endif
                            
                              let b = airline#extensions#tabline#new_builder()
                            
                              for i in range(1, tabpagenr('$'))
                                if i == curtab
                                  let group = 'airline_tabsel'
                                  if g:airline_detect_modified
                                    for bi in tabpagebuflist(i)
                                      if getbufvar(bi, '&modified')
                                        let group = 'airline_tabmod'
                                      endif
                                    endfor
                                  endif
                                  let s:current_modified = (group == 'airline_tabmod') ? 1 : 0
                                else
                                  let group = 'airline_tab'
                                endif
                                let val = '%('
                                if s:show_tab_nr
                                  if s:tab_nr_type == 0
                                    let val .= (g:airline_symbols.space).'%{len(tabpagebuflist('.i.'))}'
                                  elseif s:tab_nr_type == 1
                                    let val .= (g:airline_symbols.space).i
                                  else "== 2
                                    let val .= (g:airline_symbols.space).i.'.%{len(tabpagebuflist('.i.'))}'
                                  endif
                                endif
                                call b.add_section(group, val.'%'.i.'T %{airline#extensions#tabline#title('.i.')} %)')
                              endfor
                            
                              call b.add_section('airline_tabfill', '')
                              call b.split()
                              call b.add_section('airline_tabfill', '')
                            
                              if s:show_close_button
                                call b.add_section('airline_tab_right', ' %999X'.s:close_symbol.' ')
                              endif
                            
                              if s:show_splits == 1
                                let buffers = tabpagebuflist(curtab)
                                for nr in buffers
                                  let group = airline#extensions#tabline#group_of_bufnr(buffers, nr) . "_right"
                                  call b.add_section_spaced(group, '%(%{airline#extensions#tabline#get_buffer_name('.nr.')}%)')
                                endfor
                              elseif s:show_tab_type == 1
                                call b.add_section_spaced('airline_tabtype', s:tabs_label)
                              endif
                            
                              let s:current_bufnr = curbuf
                              let s:current_tabnr = curtab
                              let s:current_tabline = b.build()
                              return s:current_tabline

FUNCTION  412()
Called 2 times
Total time:   0.000025
 Self time:   0.000025

count  total (s)   self (s)
    2              0.000009     if exists('self._tagfolds_old')
    2              0.000011         unlet self._tagfolds_old
    2              0.000002     endif

FUNCTION  277()
Called 2 times
Total time:   2.361074
 Self time:   0.000293

count  total (s)   self (s)
    2              0.000007     let checker_start = reltime()
    2              0.000006     let name = self._filetype . '/' . self._name
                            
    2              0.000005     if has_key(self, '_enable')
                                    let status = syntastic#util#var(self._enable, -1)
                                    if type(status) != type(0)
                                        call syntastic#log#error('checker ' . name . ': invalid value ' . strtrans(string(status)) . ' for g:syntastic_' . self._enable . '; try 0 or 1 instead')
                                        return []
                                    endif
                                    if status < 0
                                        call syntastic#log#error('checker ' . name . ': checks disabled for security reasons; ' . 'set g:syntastic_' . self._enable . ' to 1 to override')
                                    endif
                                    if status <= 0
                                        call syntastic#log#debug(g:_SYNTASTIC_DEBUG_TRACE, 'getLocList: checker ' . name . ' enabled but not forced')
                                        return []
                                    else
                                        call syntastic#log#debug(g:_SYNTASTIC_DEBUG_TRACE, 'getLocList: checker ' . name . ' forced')
                                    endif
                                endif
                            
    2              0.000003     try
    2   2.360409   0.000039         let list = self._locListFunc()
    2              0.000007         if self._exec !=# ''
    2   0.000048   0.000024             call syntastic#log#debug(g:_SYNTASTIC_DEBUG_TRACE, 'getLocList: checker ' . name . ' returned ' . v:shell_error)
    2              0.000003         endif
    2              0.000003     catch /\m\C^Syntastic: checker error$/
                                    let list = []
                                    if self._exec !=# ''
                                        call syntastic#log#error('checker ' . name . ' returned abnormal status ' . v:shell_error)
                                    else
                                        call syntastic#log#error('checker ' . name . ' aborted')
                                    endif
                                endtry
    2   0.000108   0.000018     call self._populateHighlightRegexes(list)
    2   0.000052   0.000017     call syntastic#log#debug(g:_SYNTASTIC_DEBUG_LOCLIST, name . ' raw:', list)
    2   0.000254   0.000016     call self._quietMessages(list)
    2   0.000076   0.000052     call syntastic#log#debug(g:_SYNTASTIC_DEBUG_TRACE, 'getLocList: checker ' . name . ' run in ' . split(reltimestr(reltime(checker_start)))[0] . 's')
    2              0.000006     return list

FUNCTION  <SNR>150_GetNearbyTag()
Called 11 times
Total time:   0.001102
 Self time:   0.000974

count  total (s)   self (s)
   11              0.000027     if s:nearby_disabled
                                    return {}
                                endif
                            
   11   0.000140   0.000084     let fileinfo = s:known_files.getCurrent(a:forcecurrent)
   11              0.000029     if empty(fileinfo)
                                    return {}
                                endif
                            
   11              0.000031     let typeinfo = fileinfo.typeinfo
   11              0.000020     if a:0 > 0
                                    let curline = a:1
                                else
   11              0.000039         let curline = line('.')
   11              0.000014     endif
   11              0.000024     let tag = {}
                            
                                " If a tag appears in a file more than once (for example namespaces in
                                " C++) only one of them has a 'tline' entry and can thus be highlighted.
                                " The only way to solve this would be to go over the whole tag list again,
                                " making everything slower. Since this should be a rare occurence and
                                " highlighting isn't /that/ important ignore it for now.
   23              0.000089     for line in range(curline, 1, -1)
   23              0.000098         if has_key(fileinfo.fline, line)
   11              0.000041             let curtag = fileinfo.fline[line]
   11   0.000151   0.000079             if a:all || typeinfo.getKind(curtag.fields.kind).stl
   11              0.000026                 let tag = curtag
   11              0.000013                 break
                                        endif
                                    endif
   12              0.000013     endfor
                            
   11              0.000016     return tag

FUNCTION  <SNR>66__skip_file()
Called 3 times
Total time:   0.000269
 Self time:   0.000145

count  total (s)   self (s)
    3              0.000011     let fname = bufname(a:buf)
    3   0.000235   0.000111     let skip = s:_is_quitting(a:buf) || getbufvar(a:buf, 'syntastic_skip_checks') || (getbufvar(a:buf, '&buftype') !=# '') || !filereadable(fname) || getwinvar(0, '&diff') || getwinvar(0, '&previewwindow') || s:_ignore_file(fname) || fnamemodify(fname, ':e') =~? g:syntastic_ignore_extensions
    3              0.000004     if skip
                                    call syntastic#log#debug(g:_SYNTASTIC_DEBUG_TRACE, '_skip_file: skipping checks')
                                endif
    3              0.000004     return skip

FUNCTION  379()
Called 32 times
Total time:   0.001927
 Self time:   0.000707

count  total (s)   self (s)
   32              0.000386     let newobj = copy(self)
                            
   32   0.001416   0.000196     call newobj._init(a:name)
                            
   32              0.000067     return newobj

FUNCTION  gitgutter#utility#set_buffer()
Called 7 times
Total time:   0.000125
 Self time:   0.000125

count  total (s)   self (s)
    7              0.000023   let s:bufnr = a:bufnr
    7              0.000094   let s:file = resolve(bufname(a:bufnr))

FUNCTION  syntastic#util#system()
Called 2 times
Total time:   2.358166
 Self time:   0.000549

count  total (s)   self (s)
    2              0.000005     let old_shell = &shell
    2              0.000008     let old_lc_messages = $LC_MESSAGES
    2              0.000004     let old_lc_all = $LC_ALL
                            
    2   0.000036   0.000013     let &shell = syntastic#util#var('shell')
    2              0.000009     let $LC_MESSAGES = 'C'
    2              0.000004     let $LC_ALL = ''
                            
    2              0.000006     let cmd_start = reltime()
    2   2.357739   0.000220     let out = system(a:command)
    2              0.000130     let cmd_time = split(reltimestr(reltime(cmd_start)))[0]
                            
    2              0.000023     let $LC_ALL = old_lc_all
    2              0.000008     let $LC_MESSAGES = old_lc_messages
                            
    2              0.000027     let &shell = old_shell
                            
    2              0.000015     if exists('g:_SYNTASTIC_DEBUG_TRACE')
    2   0.000119   0.000044         call syntastic#log#debug(g:_SYNTASTIC_DEBUG_TRACE, 'system: command run in ' . cmd_time . 's')
    2              0.000003     endif
                            
    2              0.000005     return out

FUNCTION  airline#util#wrap()
Called 104 times
Total time:   0.000807
 Self time:   0.000807

count  total (s)   self (s)
  104              0.000322   if a:minwidth > 0 && winwidth(0) < a:minwidth
                                return ''
                              endif
  104              0.000165   return a:text

FUNCTION  gitgutter#debug#log()
Called 6 times
Total time:   0.000317
 Self time:   0.000317

count  total (s)   self (s)
    6              0.000016   if g:gitgutter_log
                                if s:new_log_session && gitgutter#async#available()
                                  if exists('*ch_logfile')
                                    call ch_logfile(s:channel_log, 'w')
                                  endif
                                endif
                            
                                execute 'redir >> '.s:log_file
                                  if s:new_log_session
                                    let s:start = reltime()
                                    silent echo "\n==== start log session ===="
                                  endif
                            
                                  let elapsed = reltimestr(reltime(s:start)).' '
                                  silent echo ''
                                  " callers excluding this function
                                  silent echo elapsed.expand('<sfile>')[:-22].':'
                                  silent echo elapsed.s:format_for_log(a:message)
                                  if a:0 && !empty(a:1)
                                    for msg in a:000
                                      silent echo elapsed.s:format_for_log(msg)
                                    endfor
                                  endif
                                redir END
                            
                                let s:new_log_session = 0
                              endif

FUNCTION  310()
Called 13 times
Total time:   0.001121
 Self time:   0.001121

count  total (s)   self (s)
   13              0.000051     if !exists('self._stl_format')
   11              0.000029         let self._stl_format = ''
   11              0.000013     endif
   13              0.000036     if !exists('self._stl_flag')
   11              0.000024         let self._stl_flag = ''
   11              0.000012     endif
                            
   13              0.000038     if g:syntastic_stl_format !=# self._stl_format
   11              0.000029         let self._stl_format = g:syntastic_stl_format
                            
   11              0.000034         if !empty(self._rawLoclist)
                                        let errors = self.errors()
                                        let warnings = self.warnings()
                            
                                        let num_errors = len(errors)
                                        let num_warnings = len(warnings)
                                        let num_issues = len(self._rawLoclist)
                            
                                        let output = self._stl_format
                            
                                        "hide stuff wrapped in %E(...) unless there are errors
                                        let output = substitute(output, '\m\C%E{\([^}]*\)}', num_errors ? '\1' : '' , 'g')
                            
                                        "hide stuff wrapped in %W(...) unless there are warnings
                                        let output = substitute(output, '\m\C%W{\([^}]*\)}', num_warnings ? '\1' : '' , 'g')
                            
                                        "hide stuff wrapped in %B(...) unless there are both errors and warnings
                                        let output = substitute(output, '\m\C%B{\([^}]*\)}', (num_warnings && num_errors) ? '\1' : '' , 'g')
                            
                                        let flags = { '%':  '%', 't':  num_issues, 'e':  num_errors, 'w':  num_warnings, 'N':  (num_issues ? fnamemodify( bufname(self._rawLoclist[0]['bufnr']), ':t') : ''), 'P':  (num_issues ? fnamemodify( bufname(self._rawLoclist[0]['bufnr']), ':p:~:.') : ''), 'F':  (num_issues ? self._rawLoclist[0]['lnum'] : ''), 'ne': (num_errors ? fnamemodify( bufname(errors[0]['bufnr']), ':t') : ''), 'pe': (num_errors ? fnamemodify( bufname(errors[0]['bufnr']), ':p:~:.') : ''), 'fe': (num_errors ? errors[0]['lnum'] : ''), 'nw': (num_warnings ? fnamemodify( bufname(warnings[0]['bufnr']), ':t') : ''), 'pw': (num_warnings ? fnamemodify( bufname(warnings[0]['bufnr']), ':p:~:.') : ''), 'fw': (num_warnings ? warnings[0]['lnum'] : '') }
                                        let output = substitute(output, '\v\C\%(-?\d*%(\.\d+)?)([npf][ew]|[NPFtew%])', '\=syntastic#util#wformat(submatch(1), flags[submatch(2)])', 'g')
                            
                                        let self._stl_flag = output
                                    else
   11              0.000023             let self._stl_flag = ''
   11              0.000011         endif
   11              0.000018     endif
                            
   13              0.000028     return self._stl_flag

FUNCTION  380()
Called 32 times
Total time:   0.001220
 Self time:   0.001220

count  total (s)   self (s)
   32              0.000132     let self.name          = a:name
   32              0.000104     let self.fields        = {}
   32              0.000092     let self.fields.line   = 0
   32              0.000095     let self.fields.column = 0
   32              0.000081     let self.prototype     = ''
   32              0.000097     let self.path          = ''
   32              0.000091     let self.fullpath      = a:name
   32              0.000083     let self.depth         = 0
   32              0.000095     let self.parent        = {}
   32              0.000078     let self.tline         = -1
   32              0.000082     let self.fileinfo      = {}
   32              0.000107     let self.typeinfo      = {}

FUNCTION  <SNR>150_ExecuteCtagsOnFile()
Called 2 times
Total time:   0.016349
 Self time:   0.000591

count  total (s)   self (s)
    2   0.000045   0.000021     call s:debug('ExecuteCtagsOnFile called [' . a:fname . ']')
                            
    2              0.000011     if has_key(a:typeinfo, 'ctagsargs') && type(a:typeinfo.ctagsargs) == type('')
                                    " if ctagsargs is a string, prepend and append space separators
                                    let ctags_args = ' ' . a:typeinfo.ctagsargs . ' '
                                elseif has_key(a:typeinfo, 'ctagsargs') && type(a:typeinfo.ctagsargs) == type([])
                                    let ctags_args = a:typeinfo.ctagsargs
                                " otherwise ctagsargs is not defined or not defined as a valid type
                                else
                                    "Prefer constructing ctags_args as a list rather than a string
                                    "See s:EscapeCtagsCmd() - It's a best practice to shellescape()
                                    "each arg separately because in special cases where space is
                                    "intended to be in an argument, spaces in a single ctag_args
                                    "string would be ambiguous. Is the space an argument separator
                                    "or to be included in the argument
    2              0.000014         let ctags_args  = [ '-f', '-', '--format=2', '--excmd=pattern', '--fields=nksSaf', '--extra=', '--file-scope=yes', '--sort=no', '--append=no' ]
                            
                                    " Include extra type definitions
    2              0.000007         if has_key(a:typeinfo, 'deffile')
                                        let ctags_args += ['--options=' . expand(a:typeinfo.deffile)]
                                    endif
                            
                                    " Third-party programs may not necessarily make use of this
    2              0.000006         if has_key(a:typeinfo, 'ctagstype')
    2              0.000006             let ctags_type = a:typeinfo.ctagstype
                            
    2              0.000006             let ctags_kinds = ''
   14              0.000031             for kind in a:typeinfo.kinds
   12              0.000042                 let ctags_kinds .= kind.short
   12              0.000017             endfor
                            
    2              0.000013             let ctags_args += ['--language-force=' . ctags_type]
    2              0.000012             let ctags_args += ['--' . ctags_type . '-kinds=' . ctags_kinds]
    2              0.000004         endif
    2              0.000002     endif
                            
    2              0.000007     if has_key(a:typeinfo, 'ctagsbin')
                                    " reset 'wildignore' temporarily in case *.exe is included in it
                                    let wildignore_save = &wildignore
                                    set wildignore&
                                    let ctags_bin = expand(a:typeinfo.ctagsbin)
                                    let &wildignore = wildignore_save
                                else
    2              0.000009         let ctags_bin = g:tagbar_ctags_bin
    2              0.000004     endif
                            
    2   0.000731   0.000031     let ctags_cmd = s:EscapeCtagsCmd(ctags_bin, ctags_args, a:fname)
    2              0.000004     if ctags_cmd == ''
                                    return ''
                                endif
                            
    2   0.015037   0.000048     let ctags_output = s:ExecuteCtags(ctags_cmd)
                            
    2              0.000043     if v:shell_error || ctags_output =~ 'Warning: cannot open source file'
                                    call s:debug('Command output:')
                                    call s:debug(ctags_output)
                                    " Only display an error message if the Tagbar window is open and we
                                    " haven't seen the error before.
                                    if bufwinnr("__Tagbar__") != -1 && (!s:known_files.has(a:realfname) || !empty(s:known_files.get(a:realfname)))
                                        call s:warning('Tagbar: Could not execute ctags for ' . a:realfname . '!')
                                        echomsg 'Executed command: "' . ctags_cmd . '"'
                                        if !empty(ctags_output)
                                            echomsg 'Command output:'
                                            for line in split(ctags_output, '\n')
                                                echomsg line
                                            endfor
                                        endif
                                    endif
                                    return -1
                                endif
                            
    2   0.000075   0.000030     call s:debug('Ctags executed successfully')
    2              0.000008     return ctags_output

FUNCTION  <SNR>66_UpdateErrors()
Called 2 times
Total time:   2.365248
 Self time:   0.000302

count  total (s)   self (s)
    2   0.000042   0.000022     call syntastic#log#debugShowVariables(g:_SYNTASTIC_DEBUG_TRACE, 'version')
    2   0.000033   0.000017     call syntastic#log#debugShowOptions(g:_SYNTASTIC_DEBUG_TRACE, s:_DEBUG_DUMP_OPTIONS)
    2   0.000037   0.000015     call syntastic#log#debugDump(g:_SYNTASTIC_DEBUG_VARIABLES)
    2   0.000045   0.000024     call syntastic#log#debug(g:_SYNTASTIC_DEBUG_TRACE, 'UpdateErrors' . (a:auto_invoked ? ' (auto)' : '') . ': ' . (len(a:checker_names) ? join(a:checker_names) : 'default checkers'))
                            
    2   0.000063   0.000012     call s:modemap.synch()
                            
    2   0.000202   0.000015     if s:_skip_file(a:buf)
                                    return
                                endif
                            
    2   0.000140   0.000017     let run_checks = !a:auto_invoked || s:modemap.doAutoChecking()
    2              0.000002     if run_checks
    1   2.362912   0.000024         call s:CacheErrors(a:buf, a:checker_names)
    1   0.000030   0.000018         call syntastic#util#setLastTick(a:buf)
    1              0.000001     else
    1              0.000002         if a:auto_invoked
    1              0.000001             return
                                    endif
                                endif
                            
    1   0.000084   0.000021     let loclist = g:SyntasticLoclist.current(a:buf)
                            
    1              0.000005     if exists('*SyntasticCheckHook')
                                    call SyntasticCheckHook(loclist.getRaw())
                                endif
                            
                                " populate loclist and jump {{{3
    1   0.000032   0.000010     let do_jump = syntastic#util#var('auto_jump') + 0
    1              0.000003     if do_jump == 2
                                    let do_jump = loclist.getFirstError(1)
                                elseif do_jump == 3
                                    let do_jump = loclist.getFirstError()
                                elseif 0 > do_jump || do_jump > 3
                                    let do_jump = 0
                                endif
                            
    1   0.000026   0.000007     if syntastic#util#var('always_populate_loc_list') || do_jump
                                    call loclist.setloclist(1)
                                    if run_checks && do_jump && !loclist.isEmpty()
                                        call syntastic#log#debug(g:_SYNTASTIC_DEBUG_NOTIFICATIONS, 'loclist: jump')
                                        execute 'silent! lrewind ' . do_jump
                            
                                        " XXX: Vim doesn't call autocmd commands in a predictible
                                        " order, which can lead to missing filetype when jumping
                                        " to a new file; the following is a workaround for the
                                        " resulting brain damage
                                        if &filetype ==# ''
                                            silent! filetype detect
                                        endif
                                    endif
                                endif
                                " }}}3
                            
    1   0.001513   0.000011     call s:notifiers.refresh(loclist)

FUNCTION  <SNR>150_HighlightTag()
Called 3 times
Total time:   0.000391
 Self time:   0.000114

count  total (s)   self (s)
    3              0.000009     let tagline = 0
                            
    3              0.000010     let force = a:0 > 0 ? a:1 : 0
                            
    3              0.000004     if a:0 > 1
                                    let tag = s:GetNearbyTag(1, 0, a:2)
                                else
    3   0.000298   0.000021         let tag = s:GetNearbyTag(1, 0)
    3              0.000004     endif
    3              0.000007     if !empty(tag)
    3              0.000012         let tagline = tag.tline
    3              0.000005     endif
                            
                                " Don't highlight the tag again if it's the same one as last time.
                                " This prevents the Tagbar window from jumping back after scrolling with
                                " the mouse.
    3              0.000010     if !force && tagline == s:last_highlight_tline
    3              0.000003         return
                                else
                                    let s:last_highlight_tline = tagline
                                endif
                            
                                let tagbarwinnr = bufwinnr('__Tagbar__')
                                if tagbarwinnr == -1
                                    return
                                endif
                                let prevwinnr = winnr()
                                call s:goto_win(tagbarwinnr)
                            
                                match none
                            
                                " No tag above cursor position so don't do anything
                                if tagline == 0
                                    call s:goto_win(prevwinnr)
                                    redraw
                                    return
                                endif
                            
                                if g:tagbar_autoshowtag == 1 || a:openfolds
                                    call s:OpenParents(tag)
                                endif
                            
                                " Check whether the tag is inside a closed fold and highlight the parent
                                " instead in that case
                                let tagline = tag.getClosedParentTline()
                            
                                " Parent tag line number is invalid, better don't do anything
                                if tagline <= 0
                                    call s:goto_win(prevwinnr)
                                    redraw
                                    return
                                endif
                            
                                " Go to the line containing the tag
                                execute tagline
                            
                                " Make sure the tag is visible in the window
                                call winline()
                            
                                let foldpat = '[' . s:icon_open . s:icon_closed . ' ]'
                                let pattern = '/^\%' . tagline . 'l\s*' . foldpat . '[-+# ]\zs[^( ]\+\ze/'
                                call s:debug("Highlight pattern: '" . pattern . "'")
                                if hlexists('TagbarHighlight') " Safeguard in case syntax highlighting is disabled
                                    execute 'match TagbarHighlight ' . pattern
                                else
                                    execute 'match Search ' . pattern
                                endif
                            
                            
                                if a:0 <= 1 " no line explicitly given, so assume we were in the file window
                                    call s:goto_win(prevwinnr)
                                endif
                            
                                redraw

FUNCTION  syntastic#log#debugShowVariables()
Called 3 times
Total time:   0.000028
 Self time:   0.000019

count  total (s)   self (s)
    3   0.000022   0.000013     if !s:_isDebugEnabled(a:level)
    3              0.000003         return
                                endif
                            
                                let leader = s:_log_timestamp()
                                call s:_logRedirect(1)
                            
                                let vlist = type(a:names) == type('') ? [a:names] : a:names
                                for name in vlist
                                    let msg = s:_format_variable(name)
                                    if msg !=# ''
                                        echomsg leader . msg
                                    endif
                                endfor
                            
                                call s:_logRedirect(0)

FUNCTION  airline#extensions#tabline#get()
Called 2 times
Total time:   0.000546
 Self time:   0.000091

count  total (s)   self (s)
    2              0.000009   let curtabcnt = tabpagenr('$')
    2              0.000007   if curtabcnt != s:current_tabcnt
                                let s:current_tabcnt = curtabcnt
                                call airline#extensions#tabline#tabs#invalidate()
                                call airline#extensions#tabline#buffers#invalidate()
                                call airline#extensions#tabline#ctrlspace#invalidate()
                              endif
                            
    2              0.000011   if !exists('#airline#BufAdd#*')
                                autocmd airline BufAdd * call <sid>update_tabline()
                              endif
    2              0.000002   if s:ctrlspace
                                return airline#extensions#tabline#ctrlspace#get()
                              elseif s:show_buffers && curtabcnt == 1 || !s:show_tabs
                                return airline#extensions#tabline#buffers#get()
                              else
    2   0.000475   0.000020     return airline#extensions#tabline#tabs#get()
                              endif

FUNCTION  gitgutter#hunk#hunks()
Called 2 times
Total time:   0.000006
 Self time:   0.000006

count  total (s)   self (s)
    2              0.000004   return s:hunks

FUNCTION  airline#extensions#tabline#title()
Called 4 times
Total time:   0.000566
 Self time:   0.000163

count  total (s)   self (s)
    4              0.000010   let title = ''
    4              0.000006   if s:taboo
                                let title = TabooTabTitle(a:n)
                              endif
                            
    4              0.000016   if empty(title) && exists('*gettabvar')
    4              0.000013     let title = gettabvar(a:n, 'title')
    4              0.000004   endif
                            
    4              0.000007   if empty(title)
    4              0.000012     let buflist = tabpagebuflist(a:n)
    4              0.000010     let winnr = tabpagewinnr(a:n)
    4   0.000044   0.000020     let all_buffers = airline#extensions#tabline#buflist#list()
    4   0.000423   0.000044     return airline#extensions#tabline#get_buffer_name( buflist[winnr - 1], filter(buflist, 'index(all_buffers, v:val) != -1'))
                              endif
                            
                              return title

FUNCTION  syntastic#util#getbufvar()
Called 16 times
Total time:   0.000139
 Self time:   0.000139

count  total (s)   self (s)
   16              0.000126     return a:0 ? s:_getbufvar(a:buf, a:name, a:1) : getbufvar(a:buf, a:name)

FUNCTION  <SNR>112_check_mixed_indent_file()
Called 3 times
Total time:   0.000213
 Self time:   0.000213

count  total (s)   self (s)
    3              0.000020   if index(s:c_like_langs, &ft) > -1
                                " for C-like languages: allow /** */ comment style with one space before the '*'
    3              0.000008     let head_spc = '\v(^ +\*@!)'
    3              0.000004   else
                                let head_spc = '\v(^ +)'
                              endif
    3              0.000067   let indent_tabs = search('\v(^\t+)', 'nw')
    3              0.000073   let indent_spc  = search(head_spc, 'nw')
    3              0.000010   if indent_tabs > 0 && indent_spc > 0
                                return printf("%d:%d", indent_tabs, indent_spc)
                              else
    3              0.000004     return ''
                              endif

FUNCTION  <SNR>108_is_branch_empty()
Called 13 times
Total time:   0.003259
 Self time:   0.000155

count  total (s)   self (s)
   13   0.003252   0.000148   return exists('*airline#extensions#branch#head') && empty(airline#extensions#branch#head())

FUNCTION  <SNR>150_debug()
Called 56 times
Total time:   0.000626
 Self time:   0.000626

count  total (s)   self (s)
   56              0.000110     if s:debug
                                    execute 'redir >> ' . s:debug_file
                                    silent echon s:gettime() . ': ' . a:msg . "\n"
                                    redir END
                                endif

FUNCTION  airline#extensions#tabline#formatters#default#wrap_name()
Called 6 times
Total time:   0.000114
 Self time:   0.000114

count  total (s)   self (s)
    6              0.000022   let _ = s:buf_nr_show ? printf(s:buf_nr_format, a:bufnr) : ''
    6              0.000036   let _ .= substitute(a:buffer_name, '\\', '/', 'g')
                            
    6              0.000022   if getbufvar(a:bufnr, '&modified') == 1
    2              0.000006     let _ .= s:buf_modified_symbol
    2              0.000001   endif
    6              0.000007   return _

FUNCTION  <SNR>34_addtomrufs()
Called 2 times
Total time:   0.000300
 Self time:   0.000300

count  total (s)   self (s)
    2              0.000052 	let fn = fnamemodify(a:fname, ':p')
    2              0.000026 	let fn = exists('+ssl') ? tr(fn, '/', '\') : fn
    2              0.000172 	if ( !empty({s:in}) && fn !~# {s:in} ) || ( !empty({s:ex}) && fn =~# {s:ex} ) || !empty(getbufvar('^'.fn.'$', '&bt')) || !filereadable(fn) | retu
                            	en
    2              0.000017 	let idx = index(s:mrufs, fn, 0, !{s:cseno})
    2              0.000003 	if idx
                            		cal filter(s:mrufs, 'v:val !='.( {s:cseno} ? '#' : '?' ).' fn')
                            		cal insert(s:mrufs, fn)
                            		if {s:soup} && idx < 0
                            			cal s:savetofile(s:mergelists())
                            		en
                            	en

FUNCTION  gitgutter#utility#using_xolox_shell()
Called 2 times
Total time:   0.000041
 Self time:   0.000041

count  total (s)   self (s)
    2              0.000006   if s:using_xolox_shell == -1
                                if !g:gitgutter_avoid_cmd_prompt_on_windows
                                  let s:using_xolox_shell = 0
                                " Although xolox/vim-shell works on both windows and unix we only want to use
                                " it on windows.
                                elseif has('win32') || has('win64') || has('win32unix')
                                  let s:using_xolox_shell = exists('g:xolox#misc#version') && exists('g:xolox#shell#version')
                                else
                                  let s:using_xolox_shell = 0
                                endif
                              endif
    2              0.000003   return s:using_xolox_shell

FUNCTION  syntastic#util#var()
Called 45 times
Total time:   0.000671
 Self time:   0.000374

count  total (s)   self (s)
   45   0.000645   0.000348     return call('syntastic#util#rawVar', ['syntastic_' . a:name] + a:000)

FUNCTION  syntastic#util#compareLexi()
Called 3 times
Total time:   0.000083
 Self time:   0.000083

count  total (s)   self (s)
    3              0.000025     for idx in range(max([len(a:a), len(a:b)]))
    2              0.000014         let a_element = str2nr(get(a:a, idx, 0))
    2              0.000015         let b_element = str2nr(get(a:b, idx, 0))
    2              0.000006         if a_element != b_element
    2              0.000008             return a_element > b_element ? 1 : -1
                                    endif
                                endfor
                                " still here, thus everything matched
    1              0.000001     return 0

FUNCTION  <SNR>150_SortTags()
Called 2 times
Total time:   0.002590
 Self time:   0.000515

count  total (s)   self (s)
    2   0.002297   0.000222     call sort(a:tags, a:comparemethod)
                            
   28              0.000043     for tag in a:tags
   26              0.000073         if has_key(tag, 'children')
                                        call s:SortTags(tag.children, a:comparemethod)
                                    endif
   26              0.000030     endfor

FUNCTION  gitgutter#utility#shellescape()
Called 6 times
Total time:   0.000168
 Self time:   0.000127

count  total (s)   self (s)
    6              0.000058   if a:arg =~ '^[A-Za-z0-9_/.-]\+$'
    4              0.000009     return a:arg
                              elseif &shell =~# 'cmd' || gitgutter#utility#using_xolox_shell()
                                return '"' . substitute(substitute(a:arg, '"', '""', 'g'), '%', '"%"', 'g') . '"'
                              else
    2              0.000008     return shellescape(a:arg)
                              endif

FUNCTION  <SNR>66__resolve_filetypes()
Called 1 time
Total time:   0.000013
 Self time:   0.000013

count  total (s)   self (s)
    1              0.000005     let type = len(a:filetypes) ? a:filetypes[0] : &filetype
    1              0.000008     return split( get(g:syntastic_filetype_map, type, type), '\m\.' )

FUNCTION  airline#parts#ffenc()
Called 13 times
Total time:   0.000276
 Self time:   0.000276

count  total (s)   self (s)
   13              0.000265   return printf('%s%s%s', &fenc, &l:bomb ? '[BOM]' : '', strlen(&ff) > 0 ? '['.&ff.']' : '')

FUNCTION  airline#parts#paste()
Called 13 times
Total time:   0.000067
 Self time:   0.000067

count  total (s)   self (s)
   13              0.000057   return g:airline_detect_paste && &paste ? g:airline_symbols.paste : ''

FUNCTION  tagbar#currenttag()
Called 8 times
Total time:   0.001922
 Self time:   0.000591

count  total (s)   self (s)
                                " Indicate that the statusline functionality is being used. This prevents
                                " the CloseWindow() function from removing the autocommands.
    8              0.000029     let s:statusline_in_use = 1
                            
    8              0.000015     if a:0 > 0
                                    " also test for non-zero value for backwards compatibility
    8              0.000085         let longsig   = a:1 =~# 's' || (type(a:1) == type(0) && a:1 != 0)
    8              0.000042         let fullpath  = a:1 =~# 'f'
    8              0.000037         let prototype = a:1 =~# 'p'
    8              0.000011     else
                                    let longsig   = 0
                                    let fullpath  = 0
                                    let prototype = 0
                                endif
                            
    8   0.000356   0.000047     if !s:Init(1)
                                    return a:default
                                endif
                            
    8   0.000883   0.000058     let tag = s:GetNearbyTag(0, 1)
                            
    8              0.000021     if !empty(tag)
    8              0.000011         if prototype
                                        return tag.getPrototype(1)
                                    else
    8   0.000276   0.000079             return printf(a:fmt, tag.str(longsig, fullpath))
                                    endif
                                else
                                    return a:default
                                endif

FUNCTION  <SNR>66__ignore_file()
Called 3 times
Total time:   0.000067
 Self time:   0.000067

count  total (s)   self (s)
    3              0.000034     let fname = fnamemodify(a:filename, ':p')
    3              0.000011     for pattern in g:syntastic_ignore_files
                                    if fname =~# pattern
                                        return 1
                                    endif
                                endfor
    3              0.000003     return 0

FUNCTION  gitgutter#async#available()
Called 2 times
Total time:   0.000008
 Self time:   0.000008

count  total (s)   self (s)
    2              0.000006   return s:available

FUNCTION  328()
Called 3 times
Total time:   0.000082
 Self time:   0.000082

count  total (s)   self (s)
    3              0.000013     if exists('g:syntastic_mode_map')
    3              0.000017         let self._mode = get(g:syntastic_mode_map, 'mode', 'active')
    3              0.000016         let self._activeFiletypes = copy(get(g:syntastic_mode_map, 'active_filetypes', []))
    3              0.000014         let self._passiveFiletypes = copy(get(g:syntastic_mode_map, 'passive_filetypes', []))
    3              0.000003     else
                                    let self._mode = 'active'
                                    let self._activeFiletypes = []
                                    let self._passiveFiletypes = []
                                endif

FUNCTION  gitgutter#utility#restore_shell()
Called 3 times
Total time:   0.000085
 Self time:   0.000085

count  total (s)   self (s)
    3              0.000013   if has('unix')
    3              0.000025     let &shell = s:shell
    3              0.000015     let &shellcmdflag = s:shellcmdflag
    3              0.000016     let &shellredir = s:shellredir
    3              0.000004   endif

FUNCTION  gitgutter#diff#run_diff()
Called 2 times
Total time:   0.002544
 Self time:   0.000417

count  total (s)   self (s)
                              " Wrap compound commands in parentheses to make Windows happy.
                              " bash doesn't mind the parentheses.
    2              0.000006   let cmd = '('
                            
    2   0.000021   0.000013   let bufnr = gitgutter#utility#bufnr()
    2              0.000011   let tracked = getbufvar(bufnr, 'gitgutter_tracked')  " i.e. tracked by git
    2              0.000003   if !tracked
                                " Don't bother trying to realtime-diff an untracked file.
                                " NOTE: perhaps we should pull this guard up to the caller?
                                if a:realtime
                                  throw 'diff failed'
                                else
                                  let cmd .= g:gitgutter_git_executable.' ls-files --error-unmatch '.gitgutter#utility#shellescape(gitgutter#utility#filename()).' && ('
                                endif
                              endif
                            
    2              0.000002   if a:realtime
                                let blob_name = g:gitgutter_diff_base.':'.gitgutter#utility#shellescape(gitgutter#utility#file_relative_to_repo_root())
                                let blob_file = s:temp_index
                                let buff_file = s:temp_buffer
                                let extension = gitgutter#utility#extension()
                                if !empty(extension)
                                  let blob_file .= '.'.extension
                                  let buff_file .= '.'.extension
                                endif
                                let cmd .= g:gitgutter_git_executable.' show '.blob_name.' > '.blob_file.' && '
                            
                                " Writing the whole buffer resets the '[ and '] marks and also the
                                " 'modified' flag (if &cpoptions includes '+').  These are unwanted
                                " side-effects so we save and restore the values ourselves.
                                let modified      = getbufvar(bufnr, "&mod")
                                let op_mark_start = getpos("'[")
                                let op_mark_end   = getpos("']")
                            
                                execute 'keepalt noautocmd silent write!' buff_file
                            
                                call setbufvar(bufnr, "&mod", modified)
                                call setpos("'[", op_mark_start)
                                call setpos("']", op_mark_end)
                              endif
                            
    2              0.000008   let cmd .= g:gitgutter_git_executable
    2              0.000003   if s:c_flag
    2              0.000005     let cmd .= ' -c "diff.autorefreshindex=0"'
    2              0.000002   endif
    2              0.000009   let cmd .= ' diff --no-ext-diff --no-color -U0 '.g:gitgutter_diff_args.' '
                            
    2              0.000003   if a:realtime
                                let cmd .= ' -- '.blob_file.' '.buff_file
                              else
    2   0.000101   0.000047     let cmd .= g:gitgutter_diff_base.' -- '.gitgutter#utility#shellescape(gitgutter#utility#filename())
    2              0.000002   endif
                            
    2              0.000006   if !a:preserve_full_diff && s:grep_available
    2   0.000116   0.000016     let cmd .= ' | '.s:grep_command.' '.gitgutter#utility#shellescape('^@@ ')
    2              0.000001   endif
                            
    2              0.000005   if (!a:preserve_full_diff && s:grep_available) || a:realtime
                                " grep exits with 1 when no matches are found; diff exits with 1 when
                                " differences are found.  However we want to treat non-matches and
                                " differences as non-erroneous behaviour; so we OR the command with one
                                " which always exits with success (0).
    2              0.000006     let cmd .= ' || exit 0'
    2              0.000001   endif
                            
    2              0.000005   let cmd .= ')'
                            
    2              0.000003   if !tracked
                                let cmd .= ')'
                              endif
                            
    2   0.000079   0.000018   let cmd = gitgutter#utility#command_in_directory_of_file(cmd)
                            
    2   0.000028   0.000020   if g:gitgutter_async && gitgutter#async#available() && !a:preserve_full_diff
    2   0.001950   0.000054     call gitgutter#async#execute(cmd)
    2              0.000011     return 'async'
                            
                              else
                                let diff = gitgutter#utility#system(cmd)
                            
                                if gitgutter#utility#shell_error()
                                  " A shell error indicates the file is not tracked by git (unless something bizarre is going on).
                                  throw 'diff failed'
                                endif
                            
                                return diff
                              endif

FUNCTION  gitgutter#sign#obsolete_gitgutter_signs_to_remove()
Called 2 times
Total time:   0.000087
 Self time:   0.000082

count  total (s)   self (s)
    2   0.000016   0.000011   let bufnr = gitgutter#utility#bufnr()
    2              0.000005   let signs_to_remove = []  " list of [<id (number)>, ...]
    2              0.000005   let remove_all_signs = 1
    2              0.000011   let old_gitgutter_signs = getbufvar(bufnr, 'gitgutter_gitgutter_signs')
    2              0.000008   for line_number in keys(old_gitgutter_signs)
                                if index(a:new_gitgutter_signs_line_numbers, str2nr(line_number)) == -1
                                  call add(signs_to_remove, old_gitgutter_signs[line_number].id)
                                else
                                  let remove_all_signs = 0
                                endif
                              endfor
    2              0.000007   let s:remove_all_old_signs = remove_all_signs
    2              0.000005   return signs_to_remove

FUNCTION  <SNR>108_get_hunks()
Called 13 times
Total time:   0.003878
 Self time:   0.000482

count  total (s)   self (s)
   13              0.000087   if !exists('b:source_func') || get(b:, 'source_func', '') is# 's:get_hunks_empty'
                                if get(g:, 'loaded_signify') && sy#buffer_is_active()
                                  let b:source_func = 's:get_hunks_signify'
                                elseif exists('*GitGutterGetHunkSummary')
                                  let b:source_func = 's:get_hunks_gitgutter'
                                elseif exists('*changes#GetStats')
                                  let b:source_func = 's:get_hunks_changes'
                                elseif exists('*quickfixsigns#vcsdiff#GetHunkSummary')
                                  let b:source_func = 'quickfixsigns#vcsdiff#GetHunkSummary'
                                else
                                  let b:source_func = 's:get_hunks_empty'
                                endif
                              endif
   13   0.003513   0.000117   return {b:source_func}()

FUNCTION  airline#parts#readonly()
Called 13 times
Total time:   0.000132
 Self time:   0.000132

count  total (s)   self (s)
   13              0.000056   if &readonly && &modifiable && !filereadable(bufname('%'))
                                return '[noperm]'
                              else
   13              0.000029     return &readonly ? g:airline_symbols.readonly : ''
                              endif

FUNCTION  <SNR>127__isDebugEnabled_smart()
Called 54 times
Total time:   0.000218
 Self time:   0.000218

count  total (s)   self (s)
   54              0.000195     return and(g:syntastic_debug, a:level)

FUNCTION  airline#extensions#syntastic#get_warnings()
Called 13 times
Total time:   0.002540
 Self time:   0.000193

count  total (s)   self (s)
   13   0.002424   0.000077   let errors = SyntasticStatuslineFlag()
   13              0.000041   if strlen(errors) > 0
                                return errors.(g:airline_symbols.space)
                              endif
   13              0.000016   return ''

FUNCTION  396()
Called 8 times
Total time:   0.000197
 Self time:   0.000197

count  total (s)   self (s)
    8              0.000019     if a:full && self.path != ''
                                    let str = self.path . self.typeinfo.sro . self.name
                                else
    8              0.000021         let str = self.name
    8              0.000010     endif
                            
    8              0.000023     if has_key(self.fields, 'signature')
                                    if a:longsig
                                        let str .= self.fields.signature
                                    else
                                        let str .= '()'
                                    endif
                                endif
                            
    8              0.000011     return str

FUNCTION  syntastic#util#bufIsActive()
Called 2 times
Total time:   0.000059
 Self time:   0.000059

count  total (s)   self (s)
                                " convert to number, or hell breaks loose
    2              0.000011     let buf = str2nr(a:buffer)
                            
    2              0.000010     if !bufloaded(buf) || !buflisted(buf)
                                    return 0
                                endif
                            
                                " get rid of hidden buffers
    2              0.000013     for tab in range(1, tabpagenr('$'))
    2              0.000009         if index(tabpagebuflist(tab), buf) >= 0
    2              0.000004             return 1
                                    endif
                                endfor
                            
                                return 0

FUNCTION  <SNR>114_update()
Called 3 times
Total time:   0.000144
 Self time:   0.000144

count  total (s)   self (s)
    3              0.000062   if match(&ft, s:filetypes) > -1
                                let l:mode = mode()
                                if l:mode ==# 'v' || l:mode ==# 'V' || l:mode ==# 's' || l:mode ==# 'S'
                                  let b:airline_wordcount = airline#extensions#wordcount#formatters#{s:formatter}#format()
                                  let b:airline_change_tick = b:changedtick
                                else
                                  if get(b:, 'airline_wordcount_cache', '') is# '' || b:airline_wordcount_cache isnot# get(b:, 'airline_wordcount', '') || get(b:, 'airline_change_tick', 0) != b:changedtick
                                    " cache data
                                    let b:airline_wordcount = airline#extensions#wordcount#formatters#{s:formatter}#format()
                                    let b:airline_wordcount_cache = b:airline_wordcount
                                    let b:airline_change_tick = b:changedtick
                                  endif
                                endif
                              endif

FUNCTION  airline#extensions#whitespace#check()
Called 13 times
Total time:   0.003008
 Self time:   0.001925

count  total (s)   self (s)
   13              0.000112   if &readonly || !&modifiable || !s:enabled || line('$') > s:max_lines || get(b:, 'airline_whitespace_disabled', 0)
                                return ''
                              endif
                            
   13              0.000050   if !exists('b:airline_whitespace_check')
    3              0.000016     let b:airline_whitespace_check = ''
    3              0.000020     let checks = get(b:, 'airline_whitespace_checks', get(g:, 'airline#extensions#whitespace#checks', s:default_checks))
                            
    3              0.000006     let trailing = 0
    3              0.000012     if index(checks, 'trailing') > -1
    3              0.000006       try
    3              0.000012         let regexp = get(g:, 'airline#extensions#whitespace#trailing_regexp', '\s$')
    3              0.000387         let trailing = search(regexp, 'nw')
    3              0.000006       catch
                                    echomsg 'airline#whitespace: error occured evaluating '. regexp
                                    echomsg v:exception
                                    return ''
                                  endtry
    3              0.000001     endif
                            
    3              0.000006     let mixed = 0
    3              0.000007     let check = 'indent'
    3              0.000034     if index(checks, check) > -1 && index(get(s:skip_check_ft, &ft, []), check) < 0
    3   0.000760   0.000031       let mixed = s:check_mixed_indent()
    3              0.000004     endif
                            
    3              0.000008     let mixed_file = ''
    3              0.000006     let check = 'mixed-indent-file'
    3              0.000030     if index(checks, check) > -1 && index(get(s:skip_check_ft, &ft, []), check) < 0
    3   0.000239   0.000026       let mixed_file = s:check_mixed_indent_file()
    3              0.000003     endif
                            
    3              0.000007     let long = 0
    3              0.000011     if index(checks, 'long') > -1 && &tw > 0
                                  let long = search('\%>'.&tw.'v.\+', 'nw')
                                endif
                            
    3              0.000012     if trailing != 0 || mixed != 0 || long != 0 || !empty(mixed_file)
                                  let b:airline_whitespace_check = s:symbol
                                  if s:show_message
                                    if trailing != 0
                                      let b:airline_whitespace_check .= (g:airline_symbols.space).printf(s:trailing_format, trailing)
                                    endif
                                    if mixed != 0
                                      let b:airline_whitespace_check .= (g:airline_symbols.space).printf(s:mixed_indent_format, mixed)
                                    endif
                                    if long != 0
                                      let b:airline_whitespace_check .= (g:airline_symbols.space).printf(s:long_format, long)
                                    endif
                                    if !empty(mixed_file)
                                      let b:airline_whitespace_check .= (g:airline_symbols.space).printf(s:mixed_indent_file_format, mixed_file)
                                    endif
                                  endif
                                endif
    3              0.000003   endif
   13   0.000224   0.000083   return airline#util#shorten(b:airline_whitespace_check, 120, 9)

FUNCTION  airline#extensions#tabline#formatters#default#format()
Called 6 times
Total time:   0.000477
 Self time:   0.000363

count  total (s)   self (s)
    6              0.000012   let _ = ''
                            
    6              0.000017   let name = bufname(a:bufnr)
    6              0.000011   if empty(name)
                                let _ .= '[No Name]'
                              else
    6              0.000007     if s:fnamecollapse
    6              0.000166       let _ .= substitute(fnamemodify(name, s:fmod), '\v\w\zs.{-}\ze(\\|/)', '', 'g')
    6              0.000008     else
                                  let _ .= fnamemodify(name, s:fmod)
                                endif
    6              0.000028     if a:bufnr != bufnr('%') && s:fnametruncate && strlen(_) > s:fnametruncate
                                  let _ = strpart(_, 0, s:fnametruncate)
                                endif
    6              0.000005   endif
                            
    6   0.000151   0.000037   return airline#extensions#tabline#formatters#default#wrap_name(a:bufnr, _)

FUNCTION  <SNR>150_ParseTagline()
Called 26 times
Total time:   0.009738
 Self time:   0.007089

count  total (s)   self (s)
   26              0.000249     let basic_info  = split(a:part1, '\t')
                            
   26   0.001844   0.000232     let taginfo      = s:NormalTag.New(basic_info[0])
   26              0.000130     let taginfo.file = basic_info[1]
                            
                                " the pattern can contain tabs and thus may have been split up, so join
                                " the rest of the items together again
   26              0.000192     let pattern = join(basic_info[2:], "\t")
   26              0.000063     let start   = 2 " skip the slash and the ^
   26              0.000135     let end     = strlen(pattern) - 1
   26              0.000120     if pattern[end - 1] ==# '$'
   26              0.000070         let end -= 1
   26              0.000061         let dollar = '\$'
   26              0.000032     else
                                    let dollar = ''
                                endif
   26              0.000144     let pattern         = strpart(pattern, start, end - start)
   26              0.000120     let taginfo.pattern = '\V\^\C' . pattern . dollar
                            
                                " When splitting fields make sure not to create empty keys or values in
                                " case a value illegally contains tabs
   26              0.000364     let fields = split(a:part2, '^\t\|\t\ze\w\+:')
   26              0.000164     if fields[0] !~# ':'
   26              0.000128         let taginfo.fields.kind = remove(fields, 0)
   26              0.000033     endif
   52              0.000121     for field in fields
                                    " can't use split() since the value can contain ':'
   26              0.000129         let delimit = stridx(field, ':')
   26              0.000109         let key = strpart(field, 0, delimit)
                                    " Remove all tabs that may illegally be in the value
   26              0.000259         let val = substitute(strpart(field, delimit + 1), '\t', '', 'g')
                                    " File-restricted scoping
   26              0.000068         if key == "file"
                                        let taginfo.fields[key] = 'yes'
                                    endif
   26              0.000096         if len(val) > 0
   26              0.000067             if key == 'line' || key == 'column'
   26              0.000123                 let taginfo.fields[key] = str2nr(val)
   26              0.000037             else
                                            let taginfo.fields[key] = val
                                        endif
   26              0.000024         endif
   26              0.000033     endfor
                                " Needed for jsctags
   26              0.000089     if has_key(taginfo.fields, 'lineno')
                                    let taginfo.fields.line = str2nr(taginfo.fields.lineno)
                                endif
                                " Do some sanity checking in case ctags reports invalid line numbers
   26              0.000057     if taginfo.fields.line < 0
                                    let taginfo.fields.line = 0
                                endif
                            
   26              0.000076     if !has_key(taginfo.fields, 'kind')
                                    call s:debug("Warning: No 'kind' field found for tag " . basic_info[0] . "!")
                                    if index(s:warnings.type, a:typeinfo.ftype) == -1
                                        call s:warning("No 'kind' field found for tag " . basic_info[0] . "!" . " Please read the last section of ':help tagbar-extend'.")
                                        call add(s:warnings.type, a:typeinfo.ftype)
                                    endif
                                    return {}
                                endif
                            
                                " Make some information easier accessible
   26              0.000081     if has_key(a:typeinfo, 'scope2kind')
                                    for scope in keys(a:typeinfo.scope2kind)
                                        if has_key(taginfo.fields, scope)
                                            let taginfo.scope = scope
                                            let taginfo.path  = taginfo.fields[scope]
                            
                                            let taginfo.fullpath = taginfo.path . a:typeinfo.sro . taginfo.name
                                            break
                                        endif
                                    endfor
                                    let taginfo.depth = len(split(taginfo.path, '\V' . a:typeinfo.sro))
                                endif
                            
   26              0.000082     let taginfo.fileinfo = a:fileinfo
   26              0.000070     let taginfo.typeinfo = a:typeinfo
                            
                                " Needed for folding
   26              0.000048     try
   26   0.001182   0.000145         call taginfo.initFoldState()
   26              0.000051     catch /^Vim(\a\+):E716:/ " 'Key not present in Dictionary'
                                    " The tag has a 'kind' that doesn't exist in the type definition
                                    call s:debug('Warning: Unknown tag kind: ' . taginfo.fields.kind)
                                    if index(s:warnings.type, a:typeinfo.ftype) == -1
                                        call s:warning('Unknown tag kind encountered: ' . '"' . taginfo.fields.kind . '".' . ' Your ctags and Tagbar configurations are out of sync!' . ' Please read '':help tagbar-extend''.')
                                        call add(s:warnings.type, a:typeinfo.ftype)
                                    endif
                                    return {}
                                endtry
                            
   26              0.000046     return taginfo

FUNCTION  <SNR>91_Highlight_Matching_Pair()
Called 3 times
Total time:   0.000431
 Self time:   0.000431

count  total (s)   self (s)
                              " Remove any previous match.
    3              0.000033   if exists('w:paren_hl_on') && w:paren_hl_on
                                silent! call matchdelete(3)
                                let w:paren_hl_on = 0
                              endif
                            
                              " Avoid that we remove the popup menu.
                              " Return when there are no colors (looks like the cursor jumps).
    3              0.000029   if pumvisible() || (&t_Co < 8 && !has("gui_running"))
                                return
                              endif
                            
                              " Get the character under the cursor and check if it's in 'matchpairs'.
    3              0.000016   let c_lnum = line('.')
    3              0.000011   let c_col = col('.')
    3              0.000007   let before = 0
                            
    3              0.000023   let text = getline(c_lnum)
    3              0.000076   let matches = matchlist(text, '\(.\)\=\%'.c_col.'c\(.\=\)')
    3              0.000011   if empty(matches)
                                let [c_before, c] = ['', '']
                              else
    3              0.000020     let [c_before, c] = matches[1:2]
    3              0.000004   endif
    3              0.000062   let plist = split(&matchpairs, '.\zs[:,]')
    3              0.000015   let i = index(plist, c)
    3              0.000005   if i < 0
                                " not found, in Insert mode try character before the cursor
    3              0.000010     if c_col > 1 && (mode() == 'i' || mode() == 'R')
                                  let before = strlen(c_before)
                                  let c = c_before
                                  let i = index(plist, c)
                                endif
    3              0.000003     if i < 0
                                  " not found, nothing to do
    3              0.000004       return
                                endif
                              endif
                            
                              " Figure out the arguments for searchpairpos().
                              if i % 2 == 0
                                let s_flags = 'nW'
                                let c2 = plist[i + 1]
                              else
                                let s_flags = 'nbW'
                                let c2 = c
                                let c = plist[i - 1]
                              endif
                              if c == '['
                                let c = '\['
                                let c2 = '\]'
                              endif
                            
                              " Find the match.  When it was just before the cursor move it there for a
                              " moment.
                              if before > 0
                                let has_getcurpos = exists("*getcurpos")
                                if has_getcurpos
                                  " getcurpos() is more efficient but doesn't exist before 7.4.313.
                                  let save_cursor = getcurpos()
                                else
                                  let save_cursor = winsaveview()
                                endif
                                call cursor(c_lnum, c_col - before)
                              endif
                            
                              " Build an expression that detects whether the current cursor position is in
                              " certain syntax types (string, comment, etc.), for use as searchpairpos()'s
                              " skip argument.
                              " We match "escape" for special items, such as lispEscapeSpecial.
                              let s_skip = '!empty(filter(map(synstack(line("."), col(".")), ''synIDattr(v:val, "name")''), ' . '''v:val =~? "string\\|character\\|singlequote\\|escape\\|comment"''))'
                              " If executing the expression determines that the cursor is currently in
                              " one of the syntax types, then we want searchpairpos() to find the pair
                              " within those syntax types (i.e., not skip).  Otherwise, the cursor is
                              " outside of the syntax types and s_skip should keep its value so we skip any
                              " matching pair inside the syntax types.
                              execute 'if' s_skip '| let s_skip = 0 | endif'
                            
                              " Limit the search to lines visible in the window.
                              let stoplinebottom = line('w$')
                              let stoplinetop = line('w0')
                              if i % 2 == 0
                                let stopline = stoplinebottom
                              else
                                let stopline = stoplinetop
                              endif
                            
                              " Limit the search time to 300 msec to avoid a hang on very long lines.
                              " This fails when a timeout is not supported.
                              if mode() == 'i' || mode() == 'R'
                                let timeout = exists("b:matchparen_insert_timeout") ? b:matchparen_insert_timeout : g:matchparen_insert_timeout
                              else
                                let timeout = exists("b:matchparen_timeout") ? b:matchparen_timeout : g:matchparen_timeout
                              endif
                              try
                                let [m_lnum, m_col] = searchpairpos(c, '', c2, s_flags, s_skip, stopline, timeout)
                              catch /E118/
                                " Can't use the timeout, restrict the stopline a bit more to avoid taking
                                " a long time on closed folds and long lines.
                                " The "viewable" variables give a range in which we can scroll while
                                " keeping the cursor at the same position.
                                " adjustedScrolloff accounts for very large numbers of scrolloff.
                                let adjustedScrolloff = min([&scrolloff, (line('w$') - line('w0')) / 2])
                                let bottom_viewable = min([line('$'), c_lnum + &lines - adjustedScrolloff - 2])
                                let top_viewable = max([1, c_lnum-&lines+adjustedScrolloff + 2])
                                " one of these stoplines will be adjusted below, but the current values are
                                " minimal boundaries within the current window
                                if i % 2 == 0
                                  if has("byte_offset") && has("syntax_items") && &smc > 0
                            	let stopbyte = min([line2byte("$"), line2byte(".") + col(".") + &smc * 2])
                            	let stopline = min([bottom_viewable, byte2line(stopbyte)])
                                  else
                            	let stopline = min([bottom_viewable, c_lnum + 100])
                                  endif
                                  let stoplinebottom = stopline
                                else
                                  if has("byte_offset") && has("syntax_items") && &smc > 0
                            	let stopbyte = max([1, line2byte(".") + col(".") - &smc * 2])
                            	let stopline = max([top_viewable, byte2line(stopbyte)])
                                  else
                            	let stopline = max([top_viewable, c_lnum - 100])
                                  endif
                                  let stoplinetop = stopline
                                endif
                                let [m_lnum, m_col] = searchpairpos(c, '', c2, s_flags, s_skip, stopline)
                              endtry
                            
                              if before > 0
                                if has_getcurpos
                                  call setpos('.', save_cursor)
                                else
                                  call winrestview(save_cursor)
                                endif
                              endif
                            
                              " If a match is found setup match highlighting.
                              if m_lnum > 0 && m_lnum >= stoplinetop && m_lnum <= stoplinebottom 
                                if exists('*matchaddpos')
                                  call matchaddpos('MatchParen', [[c_lnum, c_col - before], [m_lnum, m_col]], 10, 3)
                                else
                                  exe '3match MatchParen /\(\%' . c_lnum . 'l\%' . (c_col - before) . 'c\)\|\(\%' . m_lnum . 'l\%' . m_col . 'c\)/'
                                endif
                                let w:paren_hl_on = 1
                              endif

FUNCTION  <SNR>150_CompareByKind()
Called 62 times
Total time:   0.002075
 Self time:   0.002075

count  total (s)   self (s)
   62              0.000197     let typeinfo = s:compare_typeinfo
                            
   62              0.000243     if typeinfo.kinddict[a:tag1.fields.kind] <# typeinfo.kinddict[a:tag2.fields.kind]
   14              0.000022         return -1
                                elseif typeinfo.kinddict[a:tag1.fields.kind] ># typeinfo.kinddict[a:tag2.fields.kind]
   10              0.000011         return 1
                                else
                                    " Ignore '~' prefix for C++ destructors to sort them directly under
                                    " the constructors
   38              0.000126         if a:tag1.name[0] ==# '~'
                                        let name1 = a:tag1.name[1:]
                                    else
   38              0.000095             let name1 = a:tag1.name
   38              0.000043         endif
   38              0.000118         if a:tag2.name[0] ==# '~'
                                        let name2 = a:tag2.name[1:]
                                    else
   38              0.000091             let name2 = a:tag2.name
   38              0.000037         endif
                            
   38              0.000094         let ci = g:tagbar_case_insensitive
   38              0.000130         if (((!ci) && (name1 <=# name2)) || (ci && (name1 <=? name2)))
   30              0.000047             return -1
                                    else
    8              0.000009             return 1
                                    endif
                                endif

FUNCTION  <SNR>110_reset_untracked_cache()
Called 2 times
Total time:   0.000075
 Self time:   0.000075

count  total (s)   self (s)
    2              0.000006   if a:shellcmdpost
                                " function called after executing a shell command,
                                " only clear cache, if there was no error, else the
                                " system() command from get_git_untracked() would
                                " overwrite the v:shell_error status
                                if v:shell_error
                                  return
                                endif
                              endif
    2              0.000007   if exists("s:untracked_git")
    2              0.000031     let s:untracked_git={}
    2              0.000004   endif
    2              0.000006   if exists("s:untracked_hg")
    2              0.000006     let s:untracked_hg={}
    2              0.000003   endif

FUNCTION  gitgutter#utility#not_git_dir()
Called 3 times
Total time:   0.000116
 Self time:   0.000063

count  total (s)   self (s)
    3   0.000116   0.000063   return gitgutter#utility#full_path_to_directory_of_file() !~ '[/\\]\.git\($\|[/\\]\)'

FUNCTION  gitgutter#utility#full_path_to_directory_of_file()
Called 3 times
Total time:   0.000053
 Self time:   0.000053

count  total (s)   self (s)
    3              0.000052   return fnamemodify(s:file, ':p:h')

FUNCTION  <SNR>150_EscapeCtagsCmd()
Called 2 times
Total time:   0.000700
 Self time:   0.000608

count  total (s)   self (s)
    2   0.000042   0.000015     call s:debug('EscapeCtagsCmd called')
    2   0.000039   0.000017     call s:debug('ctags_bin: ' . a:ctags_bin)
    2              0.000010     if type(a:args)==type('')
                                    call s:debug('ctags_args (is a string): ' . a:args)
                                elseif type(a:args)==type([])
    2   0.000057   0.000035         call s:debug('ctags_args (is a list): ' . string(a:args))
    2              0.000003     endif
                            
    2              0.000009     if exists('+shellslash')
                                    let shellslash_save = &shellslash
                                    set noshellslash
                                endif
                            
                                "Set up 0th argument of ctags_cmd
                                "a:ctags_bin may have special characters that require escaping.
    2              0.000018     if &shell =~ 'cmd\.exe$' && a:ctags_bin !~ '\s'
                                    "For windows cmd.exe, escaping the 0th argument can cause
                                    "problems if it references a batch file and the batch file uses %~dp0.
                                    "So for windows cmd.exe, only escape the 0th argument iff necessary.
                                    "Only known necessary case is when ctags_bin executable filename has
                                    "whitespace character(s).
                            
                                    "  Example: If 0th argument is wrapped in double quotes AND it is not
                                    "  an absolute path to ctags_bin, but rather an executable in %PATH%,
                                    "  then %~dp0 resolves to the current working directory rather than
                                    "  the batch file's directory. Batch files like this generally exepect
                                    "  and depend on %~dp0 to resolve the batch file's directory.
                                    "  Note: Documentation such as `help cmd.exe` and
                                    "  http://www.microsoft.com/resources/documentation/windows/xp/all/proddocs/en-us/cmd.mspx?mfr=true
                                    "  suggest other special characters that require escaping for command
                                    "  line completion.  But tagbar.vim does not use the command line
                                    "  completion feature of cmd.exe and testing shows that the only special
                                    "  character that needs to be escaped for tagbar.vim is <space> for
                                    "  windows cmd.exe.
                                    let ctags_cmd = a:ctags_bin
                                else
    2              0.000013         let ctags_cmd = shellescape(a:ctags_bin)
    2              0.000002     endif
                            
                                "Add additional arguments to ctags_cmd
    2              0.000009     if type(a:args)==type('')
                                    "When a:args is a string, append the arguments
                                    "Note: In this case, do not attempt to shell escape a:args string.
                                    "This function expects the string to already be escaped properly for
                                    "the shell type. Why not escape? Because it could be ambiguous about
                                    "whether a space is an argument separator or included in the argument.
                                    "Since escaping rules vary from shell to shell, it is better to pass a
                                    "list of arguments to a:args. With a list, each argument is clearly
                                    "separated, so shellescape() can calculate the appropriate escaping
                                    "for each argument for the current &shell.
                                    let ctags_cmd .= ' ' . a:args
                                elseif type(a:args)==type([])
                                    "When a:args is a list, shellescape() each argument and append ctags_cmd
                                    "Note: It's a better practice to shellescape() each argument separately so that
                                    "spaces used as a separator between arguments can be distinguished with
                                    "spaces used inside a single argument.
   24              0.000047         for arg in a:args
   22              0.000115             let ctags_cmd .= ' ' . shellescape(arg)
   22              0.000034         endfor
    2              0.000002     endif
                            
                                "if a filename was specified, add filename as final argument to ctags_cmd.
    2              0.000006     if a:0 == 1
    2              0.000012         let ctags_cmd .= ' ' . shellescape(a:1)
    2              0.000003     endif
                            
    2              0.000008     if exists('+shellslash')
                                    let &shellslash = shellslash_save
                                endif
                            
                                " Needed for cases where 'encoding' is different from the system's
                                " encoding
    2              0.000010     if has('multi_byte')
    2              0.000019         if g:tagbar_systemenc != &encoding
                                        let ctags_cmd = iconv(ctags_cmd, &encoding, g:tagbar_systemenc)
                                    elseif $LANG != ''
    2              0.000029             let ctags_cmd = iconv(ctags_cmd, &encoding, $LANG)
    2              0.000003         endif
    2              0.000002     endif
                            
    2   0.000040   0.000019     call s:debug('Escaped ctags command: ' . ctags_cmd)
                            
    2              0.000005     if ctags_cmd == ''
                                    if !s:warnings.encoding
                                        call s:warning('Tagbar: Ctags command encoding conversion failed!' . ' Please read ":h g:tagbar_systemenc".')
                                        let s:warnings.encoding = 1
                                    endif
                                endif
                            
    2              0.000003     return ctags_cmd

FUNCTION  <SNR>66_BufWritePostHook()
Called 2 times
Total time:   2.365476
 Self time:   0.000073

count  total (s)   self (s)
    2   0.000143   0.000018     let buf = syntastic#util#fname2buf(a:fname)
    2   0.000059   0.000029     call syntastic#log#debug(g:_SYNTASTIC_DEBUG_AUTOCOMMANDS, 'autocmd: BufWritePost, buffer ' . buf . ' = ' . string(a:fname))
    2   2.365271   0.000023     call s:UpdateErrors(buf, 1, [])

FUNCTION  airline#parts#spell()
Called 13 times
Total time:   0.000076
 Self time:   0.000076

count  total (s)   self (s)
   13              0.000068   return g:airline_detect_spell && &spell ? g:airline_symbols.spell : ''

FUNCTION  408()
Called 8 times
Total time:   0.000072
 Self time:   0.000072

count  total (s)   self (s)
    8              0.000033     let idx = self.kinddict[a:kind]
    8              0.000028     return self.kinds[idx]

FUNCTION  <SNR>147_job_started()
Called 2 times
Total time:   0.000030
 Self time:   0.000030

count  total (s)   self (s)
    2              0.000003   if a:0  " vim
    2              0.000015     let s:jobs[a:id] = {'output': [], 'buffer': a:1}
    2              0.000004   else    " nvim
                                let s:jobs[a:id] = 1
                              endif

FUNCTION  <SNR>147_job_output()
Called 2 times
Total time:   0.000042
 Self time:   0.000031

count  total (s)   self (s)
    2              0.000009   if has_key(s:jobs, a:id)
    2   0.000030   0.000019     return gitgutter#utility#stringify(s:jobs[a:id].output)
                              else
                                return ""
                              endif

FUNCTION  <SNR>110_get_hg_branch()
Called 26 times
Total time:   0.000190
 Self time:   0.000190

count  total (s)   self (s)
   26              0.000056   if s:has_lawrencium
                                return lawrencium#statusline()
                              endif
   26              0.000029   return ''

FUNCTION  339()
Called 2 times
Total time:   0.000560
 Self time:   0.000355

count  total (s)   self (s)
    2   0.000033   0.000012     call syntastic#log#debug(g:_SYNTASTIC_DEBUG_NOTIFICATIONS, 'notifiers: reset')
   12              0.000018     for type in self._enabled_types
   10              0.000102         let class = substitute(type, '\m.*', 'Syntastic\u&Notifier', '')
                            
                                    " reset notifiers regardless if they are enabled or not, since
                                    " the user might have disabled them since the last refresh();
                                    " notifiers MUST be prepared to deal with reset() when disabled
   10              0.000045         if has_key(g:{class}, 'reset')
    6   0.000221   0.000037             call self._notifier[type].reset(a:loclist)
    6              0.000004         endif
                            
                                    " also reset stamps
   10              0.000031         if index(s:_PERSISTENT_NOTIFIERS, type) > -1
    4              0.000018             let b:syntastic_private_{type}_stamp = []
    4              0.000001         endif
   10              0.000007     endfor

FUNCTION  413()
Called 2 times
Total time:   0.002635
 Self time:   0.000045

count  total (s)   self (s)
    2              0.000013     if get(s:compare_typeinfo, 'sort', g:tagbar_sort)
    2   0.002609   0.000019         call s:SortTags(self.tags, 's:CompareByKind')
    2              0.000003     else
                                    call s:SortTags(self.tags, 's:CompareByLine')
                                endif

FUNCTION  416()
Called 11 times
Total time:   0.000056
 Self time:   0.000056

count  total (s)   self (s)
   11              0.000025     if !s:paused || a:forcecurrent
   11              0.000021         return self._current
                                else
                                    return self._paused
                                endif

FUNCTION  417()
Called 3 times
Total time:   0.000011
 Self time:   0.000011

count  total (s)   self (s)
    3              0.000010     let self._current = a:fileinfo

FUNCTION  SyntasticToggleMode()
Called 1 time
Total time:   0.001461
 Self time:   0.000048

count  total (s)   self (s)
    1   0.000071   0.000008     call s:modemap.toggleMode()
    1   0.000458   0.000019     call s:ClearCache(bufnr(''))
    1   0.000896   0.000012     call s:notifiers.refresh(g:SyntasticLoclist.New([]))
    1   0.000034   0.000007     call s:modemap.echoMode()

FUNCTION  gitgutter#utility#bufnr()
Called 18 times
Total time:   0.000050
 Self time:   0.000050

count  total (s)   self (s)
   18              0.000040   return s:bufnr

FUNCTION  airline#parts#crypt()
Called 13 times
Total time:   0.000107
 Self time:   0.000107

count  total (s)   self (s)
   13              0.000096   return g:airline_detect_crypt && exists("+key") && !empty(&key) ? g:airline_symbols.crypt : ''

FUNCTION  airline#extensions#tagbar#currenttag()
Called 13 times
Total time:   0.002241
 Self time:   0.000319

count  total (s)   self (s)
   13              0.000059   if get(w:, 'airline_active', 0)
   13              0.000053     if s:airline_tagbar_last_lookup_time != localtime()
    8   0.001997   0.000075       let s:airline_tagbar_last_lookup_val = tagbar#currenttag('%s', '', s:flags)
    8              0.000037       let s:airline_tagbar_last_lookup_time = localtime()
    8              0.000008     endif
   13              0.000027     return s:airline_tagbar_last_lookup_val
                              endif
                              return ''

FUNCTION  syntastic#postprocess#guards()
Called 1 time
Total time:   0.000051
 Self time:   0.000030

count  total (s)   self (s)
    1   0.000033   0.000012     let buffers = syntastic#util#unique(map(filter(copy(a:errors), 'v:val["valid"]'), 'str2nr(v:val["bufnr"])'))
                            
    1              0.000002     let guards = {}
    1              0.000002     for b in buffers
                                    let guards[b] = len(getbufline(b, 1, '$'))
                                endfor
                            
    1              0.000002     for e in a:errors
                                    if e['valid'] && e['lnum'] > guards[e['bufnr']]
                                        let e['lnum'] = guards[e['bufnr']]
                                    endif
                                endfor
                            
    1              0.000001     return a:errors

FUNCTION  420()
Called 2 times
Total time:   0.000032
 Self time:   0.000032

count  total (s)   self (s)
    2              0.000005     if a:0 == 1
                                    let self._files[a:1] = a:fileinfo
                                else
    2              0.000007         let fname = a:fileinfo.fpath
    2              0.000007         let self._files[fname] = a:fileinfo
    2              0.000002     endif

FUNCTION  421()
Called 31 times
Total time:   0.000178
 Self time:   0.000178

count  total (s)   self (s)
   31              0.000157     return has_key(self._files, a:fname)

FUNCTION  airline#extensions#branch#head()
Called 26 times
Total time:   0.005803
 Self time:   0.004572

count  total (s)   self (s)
   26              0.000139   if exists('b:airline_head') && !empty(b:airline_head)
                                return b:airline_head
                              endif
                            
   26              0.000061   let b:airline_head = ''
   26              0.000067   let l:heads = {}
   26              0.000145   let l:vcs_priority = get(g:, "airline#extensions#branch#vcs_priority", ["git", "mercurial"])
   26              0.000064   let found_fugitive_head = 0
                            
   26              0.000083   if exists("*fnamemodify")
   26   0.001622   0.000887     let l:git_head = s:get_git_branch(fnamemodify(resolve(@%), ":p:h"))
   26              0.000028   else
                                let l:git_head = s:get_git_branch(expand("%:p:h"))
                              endif
   26   0.000337   0.000147   let l:hg_head = s:get_hg_branch()
                            
   26              0.000073   if !empty(l:git_head)
                                let found_fugitive_head = 1
                                let l:heads.git = (!empty(l:hg_head) ? "git:" : '') . s:format_name(l:git_head)
                                let l:git_untracked = s:get_git_untracked(expand("%:p"))
                                let l:heads.git .= l:git_untracked
                              endif
                            
   26              0.000062   if !empty(l:hg_head)
                                let l:heads.mercurial = (!empty(l:git_head) ? "hg:" : '') . s:format_name(l:hg_head)
                                let l:hg_untracked = s:get_hg_untracked(expand("%:p"))
                                let l:heads.mercurial.= l:hg_untracked
                              endif
                            
   26              0.000067   if empty(l:heads)
   26              0.000040     if s:has_vcscommand
                                  call VCSCommandEnableBufferSetup()
                                  if exists('b:VCSCommandBufferInfo')
                                    let b:airline_head = s:format_name(get(b:VCSCommandBufferInfo, 0, ''))
                                  endif
                                endif
   26              0.000022   else
                                let b:airline_head = get(b:, 'airline_head', '')
                                for vcs in l:vcs_priority
                                  if has_key(l:heads, vcs)
                                    if !empty(b:airline_head)
                                      let b:airline_head = b:airline_head . " | "
                                    endif
                                    let b:airline_head = b:airline_head . l:heads[vcs]
                                  endif
                                endfor
                              endif
                            
   26              0.000108   if exists("g:airline#extensions#branch#displayed_head_limit")
                                let w:displayed_head_limit = g:airline#extensions#branch#displayed_head_limit
                                if len(b:airline_head) > w:displayed_head_limit - 1
                                  let b:airline_head = b:airline_head[0:(w:displayed_head_limit - 1)].(&encoding ==? 'utf-8' ?  '…' : '.')
                                endif
                              endif
                            
   26              0.000112   if empty(b:airline_head) || !found_fugitive_head && !s:check_in_path()
   26              0.000060     let b:airline_head = ''
   26              0.000022   endif
   26              0.000123   let minwidth = empty(get(b:, 'airline_hunks', '')) ? 14 : 7
   26   0.000506   0.000200   let b:airline_head = airline#util#shorten(b:airline_head, 120, minwidth)
   26              0.000049   return b:airline_head

FUNCTION  syntastic#log#debugDump()
Called 2 times
Total time:   0.000022
 Self time:   0.000014

count  total (s)   self (s)
    2   0.000018   0.000010     if !s:_isDebugEnabled(a:level)
    2              0.000002         return
                                endif
                            
                                call syntastic#log#debugShowVariables( a:level, sort(keys(g:_SYNTASTIC_DEFAULTS)) )

FUNCTION  <SNR>108_get_hunks_gitgutter()
Called 13 times
Total time:   0.003396
 Self time:   0.000137

count  total (s)   self (s)
   13   0.003364   0.000105   if !get(g:, 'gitgutter_enabled', 0) || s:is_branch_empty()
   13              0.000018     return ''
                              endif
                              return GitGutterGetHunkSummary()

FUNCTION  airline#parts#mode()
Called 13 times
Total time:   0.000078
 Self time:   0.000078

count  total (s)   self (s)
   13              0.000069   return get(w:, 'airline_current_mode', '')

FUNCTION  <SNR>147_job_finished()
Called 2 times
Total time:   0.000043
 Self time:   0.000043

count  total (s)   self (s)
    2              0.000015   if has_key(s:jobs, a:id)
    2              0.000020     unlet s:jobs[a:id]
    2              0.000005   endif

FUNCTION  gitgutter#utility#stringify()
Called 2 times
Total time:   0.000011
 Self time:   0.000011

count  total (s)   self (s)
    2              0.000010   return join(a:list, "\n")."\n"

FUNCTION  gitgutter#async#execute()
Called 2 times
Total time:   0.001896
 Self time:   0.001743

count  total (s)   self (s)
    2   0.000017   0.000012   let bufnr = gitgutter#utility#bufnr()
                            
    2              0.000013   if has('nvim')
                                if has('unix')
                                  let command = ["sh", "-c", a:cmd]
                                elseif has('win32')
                                  let command = ["cmd.exe", "/c", a:cmd]
                                else
                                  throw 'unknown os'
                                endif
                                " Make the job use a shell while avoiding (un)quoting problems.
                                let job_id = jobstart(command, { 'buffer':    bufnr, 'on_stdout': function('gitgutter#async#handle_diff_job_nvim'), 'on_stderr': function('gitgutter#async#handle_diff_job_nvim'), 'on_exit':   function('gitgutter#async#handle_diff_job_nvim') })
                                call gitgutter#debug#log('[nvim job: '.job_id.', buffer: '.bufnr.'] '.a:cmd)
                                if job_id < 1
                                  throw 'diff failed'
                                endif
                            
                                " Note that when `cmd` doesn't produce any output, i.e. the diff is empty,
                                " the `stdout` event is not fired on the job handler.  Therefore we keep
                                " track of the jobs ourselves so we can spot empty diffs.
                                call s:job_started(job_id)
                            
                              else
                                " Make the job use a shell.
                                "
                                " Pass a handler for stdout but not for stderr so that errors are
                                " ignored (and thus signs are not updated; this assumes that an error
                                " only occurs when a file is not tracked by git).
                            
    2              0.000005     if has('unix')
    2              0.000008       let command = ["sh", "-c", a:cmd]
    2              0.000004     elseif has('win32')
                                  " Help docs recommend {command} be a string on Windows.  But I think
                                  " they also say that will run the command directly, which I believe would
                                  " mean the redirection and pipe stuff wouldn't work.
                                  " let command = "cmd.exe /c ".a:cmd
                                  let command = ["cmd.exe", "/c", a:cmd]
                                else
                                  throw 'unknown os'
                                endif
                            
    2              0.001431     let job = job_start(command, { 'out_cb':   'gitgutter#async#handle_diff_job_vim', 'close_cb': 'gitgutter#async#handle_diff_job_vim_close' })
    2   0.000213   0.000118     call gitgutter#debug#log('[vim job: '.string(job_info(job)).', buffer: '.bufnr.'] '.a:cmd)
                            
    2   0.000086   0.000033     call s:job_started(s:channel_id(job_getchannel(job)), bufnr)
    2              0.000001   endif

FUNCTION  syntastic#util#fname2buf()
Called 2 times
Total time:   0.000125
 Self time:   0.000125

count  total (s)   self (s)
    2              0.000007     if exists('+shellslash')
                                    " bufnr() can't cope with backslashes
                                    let old_shellslash = &shellslash
                                    let &shellslash = 1
                                endif
                            
                                " this is a best-effort attempt to escape file patterns (cf. :h file-pattern)
                                " XXX it fails for filenames containing something like \{2,3}
    2              0.000010     for md in [':~:.', ':~', ':p']
    2              0.000054         let buf = bufnr('^' . escape(fnamemodify(a:fname, md), '\*?,{}[') . '$')
    2              0.000005         if buf != -1
    2              0.000003             break
                                    endif
                                endfor
    2              0.000004     if buf == -1
                                    " XXX definitely wrong, but hope is the last thing to die :)
                                    let buf = bufnr(fnamemodify(a:fname, ':p'))
                                endif
                            
    2              0.000006     if exists('+shellslash')
                                    let &shellslash = old_shellslash
                                endif
                            
    2              0.000003     return buf

FUNCTION  gitgutter#utility#has_unsaved_changes()
Called 2 times
Total time:   0.000021
 Self time:   0.000021

count  total (s)   self (s)
    2              0.000019   return getbufvar(s:bufnr, "&mod")

FUNCTION  SyntasticMake()
Called 2 times
Total time:   2.359395
 Self time:   0.000909

count  total (s)   self (s)
    2   0.000028   0.000011     call syntastic#log#debug(g:_SYNTASTIC_DEBUG_TRACE, 'SyntasticMake: called with options:', a:options)
                            
                                " save options and locale env variables {{{3
    2              0.000008     let old_local_errorformat = &l:errorformat
    2              0.000004     let old_errorformat = &errorformat
    2              0.000009     let old_cwd = getcwd()
                                " }}}3
                            
    2              0.000006     if has_key(a:options, 'errorformat')
    2              0.000014         let &errorformat = a:options['errorformat']
    2              0.000008         set errorformat<
    2              0.000002     endif
                            
    2              0.000006     if has_key(a:options, 'cwd')
                                    execute 'lcd ' . fnameescape(a:options['cwd'])
                                endif
                            
                                " set environment variables {{{3
    2              0.000004     let env_save = {}
    2              0.000006     if has_key(a:options, 'env') && len(a:options['env'])
                                    for key in keys(a:options['env'])
                                        if key =~? '\m^[a-z_][a-z0-9_]*$'
                                            execute 'let env_save[' . string(key) . '] = $' . key
                                            execute 'let $' . key . ' = ' . string(a:options['env'][key])
                                        endif
                                    endfor
                                endif
                                " }}}3
                            
    2   2.358212   0.000046     let err_lines = split(syntastic#util#system(a:options['makeprg']), "\n", 1)
                            
                                " restore environment variables {{{3
    2              0.000009     if len(env_save)
                                    for key in keys(env_save)
                                        execute 'let $' . key . ' = ' . string(env_save[key])
                                    endfor
                                endif
                                " }}}3
                            
    2   0.000046   0.000018     call syntastic#log#debug(g:_SYNTASTIC_DEBUG_LOCLIST, 'checker output:', err_lines)
                            
                                " Does it still make sense to go on?
    2   0.000073   0.000028     let bailout = syntastic#util#var('exit_checks') && has_key(a:options, 'returns') && index(a:options['returns'], v:shell_error) == -1
                            
    2              0.000005     if !bailout
    2              0.000006         if has_key(a:options, 'Preprocess')
                                        let err_lines = call(a:options['Preprocess'], [err_lines])
                                        call syntastic#log#debug(g:_SYNTASTIC_DEBUG_LOCLIST, 'preprocess (external):', err_lines)
                                    elseif has_key(a:options, 'preprocess')
                                        let err_lines = call('syntastic#preprocess#' . a:options['preprocess'], [err_lines])
                                        call syntastic#log#debug(g:_SYNTASTIC_DEBUG_LOCLIST, 'preprocess:', err_lines)
                                    endif
    2              0.000185         noautocmd lgetexpr err_lines
                            
    2              0.000027         let errors = deepcopy(getloclist(0))
                            
    2              0.000008         if has_key(a:options, 'cwd')
                                        execute 'lcd ' . fnameescape(old_cwd)
                                    endif
                            
    2              0.000005         try
    2              0.000033             silent lolder
    2              0.000006         catch /\m^Vim\%((\a\+)\)\=:E380/
                                        " E380: At bottom of quickfix stack
                                        call setloclist(0, [], 'r')
                                        try
                                            " Vim 7.4.2200 or later
                                            call setloclist(0, [], 'r', { 'title': '' })
                                        catch /\m^Vim\%((\a\+)\)\=:E\%(118\|731\)/
                                            " do nothing
                                        endtry
                                    catch /\m^Vim\%((\a\+)\)\=:E776/
                                        " E776: No location list
                                        " do nothing
                                    endtry
    2              0.000002     else
                                    let errors = []
                                endif
                            
                                " restore options {{{3
    2              0.000018     let &errorformat = old_errorformat
    2              0.000011     let &l:errorformat = old_local_errorformat
                                " }}}3
                            
    2   0.000062   0.000047     if !s:_running_windows && (s:_os_name() =~? 'FreeBSD' || s:_os_name() =~? 'OpenBSD')
                                    call syntastic#util#redraw(g:syntastic_full_redraws)
                                endif
                            
    2              0.000003     if bailout
                                    call syntastic#log#ndebug(g:_SYNTASTIC_DEBUG_LOCLIST, 'checker output:', err_lines)
                                    throw 'Syntastic: checker error'
                                endif
                            
    2   0.000043   0.000017     call syntastic#log#debug(g:_SYNTASTIC_DEBUG_LOCLIST, 'raw loclist:', errors)
                            
    2              0.000008     if has_key(a:options, 'defaults')
                                    call s:_add_to_errors(errors, a:options['defaults'])
                                endif
                            
                                " Add subtype info if present.
    2              0.000006     if has_key(a:options, 'subtype')
    1   0.000152   0.000022         call s:_add_to_errors(errors, { 'subtype': a:options['subtype'] })
    1              0.000001     endif
                            
    2              0.000009     if has_key(a:options, 'Postprocess') && !empty(a:options['Postprocess'])
                                    for rule in a:options['Postprocess']
                                        let errors = call(rule, [errors])
                                    endfor
                                    call syntastic#log#debug(g:_SYNTASTIC_DEBUG_LOCLIST, 'postprocess (external):', errors)
                                elseif has_key(a:options, 'postprocess') && !empty(a:options['postprocess'])
    2              0.000004         for rule in a:options['postprocess']
    1   0.000063   0.000012             let errors = call('syntastic#postprocess#' . rule, [errors])
    1              0.000001         endfor
    1   0.000015   0.000007         call syntastic#log#debug(g:_SYNTASTIC_DEBUG_LOCLIST, 'postprocess:', errors)
    1              0.000001     endif
                            
    2              0.000005     return errors

FUNCTION  <SNR>110_get_git_branch()
Called 26 times
Total time:   0.000735
 Self time:   0.000581

count  total (s)   self (s)
   26              0.000071   if !s:has_fugitive
                                return ''
                              endif
                            
   26   0.000314   0.000160   let name = fugitive#head(7)
   26              0.000062   if empty(name)
   26              0.000092     if has_key(s:git_dirs, a:path)
   26              0.000070       return s:git_dirs[a:path]
                                endif
                            
                                let dir = fugitive#extract_git_dir(a:path)
                                if empty(dir)
                                  let name = ''
                                else
                                  try
                                    let line = join(readfile(dir . '/HEAD'))
                                    if strpart(line, 0, 16) == 'ref: refs/heads/'
                                      let name = strpart(line, 16)
                                    else
                                      " raw commit hash
                                      let name = strpart(line, 0, 7)
                                    endif
                                  catch
                                    let name = ''
                                  endtry
                                endif
                              endif
                            
                              let s:git_dirs[a:path] = name
                              return name

FUNCTION  411()
Called 2 times
Total time:   0.000430
 Self time:   0.000430

count  total (s)   self (s)
    2              0.000019     let self.mtime = getftime(self.fpath)
    2              0.000025     let self.tags  = []
    2              0.000249     let self.fline = {}
    2              0.000009     let self.tline = {}
                            
    2              0.000008     let self._tagfolds_old = self.tagfolds
    2              0.000006     let self.tagfolds = {}
                            
   14              0.000035     for kind in self.typeinfo.kinds
   12              0.000044         let self.tagfolds[kind.short] = {}
   12              0.000016     endfor

FUNCTION  gitgutter#hunk#reset()
Called 2 times
Total time:   0.000025
 Self time:   0.000020

count  total (s)   self (s)
    2   0.000025   0.000020   call setbufvar(gitgutter#utility#bufnr(), 'gitgutter_summary', [0,0,0])

FUNCTION  gitgutter#utility#exists_file()
Called 3 times
Total time:   0.000041
 Self time:   0.000041

count  total (s)   self (s)
    3              0.000037   return filereadable(s:file)

FUNCTION  gitgutter#utility#is_file_buffer()
Called 3 times
Total time:   0.000021
 Self time:   0.000021

count  total (s)   self (s)
    3              0.000020   return empty(getbufvar(s:bufnr, '&buftype'))

FUNCTION  syntastic#util#unique()
Called 4 times
Total time:   0.000141
 Self time:   0.000141

count  total (s)   self (s)
    4              0.000013     let seen = {}
    4              0.000009     let uniques = []
    7              0.000014     for e in a:list
    3              0.000016         let k = string(e)
    3              0.000009         if !has_key(seen, k)
    3              0.000010             let seen[k] = 1
    3              0.000011             call add(uniques, e)
    3              0.000003         endif
    3              0.000004     endfor
    4              0.000006     return uniques

FUNCTION  gitgutter#utility#directory_of_file()
Called 2 times
Total time:   0.000010
 Self time:   0.000010

count  total (s)   self (s)
    2              0.000009   return fnamemodify(s:file, ':h')

FUNCTION  <SNR>66__os_name()
Called 4 times
Total time:   0.000015
 Self time:   0.000015

count  total (s)   self (s)
    4              0.000014     return g:_SYNTASTIC_UNAME

FUNCTION  gitgutter#utility#is_active()
Called 3 times
Total time:   0.000239
 Self time:   0.000061

count  total (s)   self (s)
    3   0.000238   0.000060   return g:gitgutter_enabled && !pumvisible() && gitgutter#utility#is_file_buffer() && gitgutter#utility#exists_file() && gitgutter#utility#not_git_dir()

FUNCTION  265()
Called 2 times
Total time:   0.000251
 Self time:   0.000026

count  total (s)   self (s)
    2   0.000035   0.000011     call syntastic#log#debug(g:_SYNTASTIC_DEBUG_NOTIFICATIONS, 'autoloclist: refresh')
    2   0.000214   0.000013     call g:SyntasticAutoloclistNotifier.AutoToggle(a:loclist)

FUNCTION  266()
Called 2 times
Total time:   0.000201
 Self time:   0.000157

count  total (s)   self (s)
    2   0.000040   0.000024     call syntastic#log#debug(g:_SYNTASTIC_DEBUG_NOTIFICATIONS, 'autoloclist: toggle')
    2   0.000032   0.000010     let auto_loc_list = syntastic#util#var('auto_loc_list')
    2   0.000015   0.000009     if !a:loclist.isEmpty()
                                    if auto_loc_list == 1 || auto_loc_list == 3
                                        call a:loclist.show()
                                    endif
                                else
    2              0.000012         if (auto_loc_list == 1 || auto_loc_list == 2) && !empty(get(w:, 'syntastic_loclist_set', []))
                                        try
                                            " Vim 7.4.2200 or later
                                            let title = get(getloclist(0, { 'title': 1 }), 'title', ':SyntasticCheck ')
                                        catch /\m^Vim\%((\a\+)\)\=:E\%(118\|731\)/
                                            let title = ':SyntasticCheck '
                                        endtry
                            
                                        if strpart(title, 0, 16) ==# ':SyntasticCheck '
                                            " TODO: this will close the loc list window if one was opened
                                            " by something other than syntastic
                                            call SyntasticLoclistHide()
                            
                                            try
                                                " Vim 7.4.2200 or later
                                                call setloclist(0, [], 'r', { 'title': '' })
                                            catch /\m^Vim\%((\a\+)\)\=:E\%(118\|731\)/
                                                " do nothing
                                            endtry
                                            let w:syntastic_loclist_set = []
                                        endif
                                    endif
    2              0.000003     endif

FUNCTION  268()
Called 4 times
Total time:   0.000091
 Self time:   0.000029

count  total (s)   self (s)
    4   0.000088   0.000026     return has('balloon_eval') && syntastic#util#var('enable_balloons')

FUNCTION  269()
Called 2 times
Total time:   0.000091
 Self time:   0.000039

count  total (s)   self (s)
    2              0.000005     unlet! b:syntastic_private_balloons
    2   0.000068   0.000016     if self.enabled() && !a:loclist.isEmpty()
                                    let b:syntastic_private_balloons = a:loclist.balloons()
                                    if !empty(b:syntastic_private_balloons)
                                        set ballooneval balloonexpr=SyntasticBalloonsExprNotifier()
                                    endif
                                endif

FUNCTION  gitgutter#utility#save_last_seen_change()
Called 2 times
Total time:   0.000016
 Self time:   0.000016

count  total (s)   self (s)
    2              0.000016   call setbufvar(s:bufnr, 'gitgutter_last_tick', getbufvar(s:bufnr, 'changedtick'))

FUNCTION  <SNR>150_SetStatusLine()
Called 3 times
Total time:   0.000175
 Self time:   0.000175

count  total (s)   self (s)
                                " Make sure we're actually in the Tagbar window
    3              0.000156     let tagbarwinnr = bufwinnr('__Tagbar__')
    3              0.000009     if tagbarwinnr == -1
    3              0.000004         return
                                endif
                                if tagbarwinnr != winnr()
                                    let in_tagbar = 0
                                    call s:goto_win(tagbarwinnr)
                                else
                                    let in_tagbar = 1
                                endif
                            
                                let sort = g:tagbar_sort ? 'Name' : 'Order'
                            
                                if !empty(s:known_files.getCurrent(0))
                                    let fname = fnamemodify(s:known_files.getCurrent(0).fpath, ':t')
                                else
                                    let fname = ''
                                endif
                            
                                let flags = []
                                let flags += exists('w:autoclose') && w:autoclose ? ['c'] : []
                                let flags += g:tagbar_autoclose ? ['C'] : []
                                let flags += (g:tagbar_sort && g:tagbar_case_insensitive) ? ['i'] : []
                                let flags += g:tagbar_hide_nonpublic ? ['v'] : []
                            
                                if exists('g:tagbar_status_func')
                                    let args = [in_tagbar, sort, fname, flags]
                                    let &l:statusline = call(g:tagbar_status_func, args)
                                else
                                    let colour = in_tagbar ? '%#StatusLine#' : '%#StatusLineNC#'
                                    let flagstr = join(flags, '')
                                    if flagstr != ''
                                        let flagstr = '[' . flagstr . '] '
                                    endif
                                    let text = colour . '[' . sort . '] ' . flagstr . fname
                                    let &l:statusline = text
                                endif
                            
                                if !in_tagbar
                                    call s:goto_win('p')
                                endif

FUNCTION  syntastic#util#setLastTick()
Called 1 time
Total time:   0.000012
 Self time:   0.000012

count  total (s)   self (s)
    1              0.000010     call setbufvar(a:buf, 'syntastic_lasttick', getbufvar(a:buf, 'changedtick'))

FUNCTION  <SNR>66_CacheErrors()
Called 1 time
Total time:   2.362888
 Self time:   0.000494

count  total (s)   self (s)
    1   0.000017   0.000008     call syntastic#log#debug(g:_SYNTASTIC_DEBUG_TRACE, 'CacheErrors: ' . (len(a:checker_names) ? join(a:checker_names) : 'default checkers'))
    1   0.000438   0.000010     call s:ClearCache(a:buf)
    1   0.000041   0.000007     let newLoclist = g:SyntasticLoclist.New([])
    1   0.000012   0.000007     call newLoclist.setOwner(a:buf)
                            
    1   0.000087   0.000005     if !s:_skip_file(a:buf)
                                    " debug logging {{{3
    1   0.000014   0.000006         call syntastic#log#debugShowVariables(g:_SYNTASTIC_DEBUG_TRACE, 'aggregate_errors')
    1   0.000015   0.000007         call syntastic#log#debug(g:_SYNTASTIC_DEBUG_CHECKERS, '$TERM = ' . string($TERM))
    1   0.000016   0.000008         call syntastic#log#debug(g:_SYNTASTIC_DEBUG_CHECKERS, '$PATH = ' . string($PATH))
    1   0.000016   0.000009         call syntastic#log#debug(g:_SYNTASTIC_DEBUG_TRACE, 'getcwd() = ' . string(getcwd()))
                                    " }}}3
                            
    1   0.000022   0.000009         let filetypes = s:_resolve_filetypes([])
    1   0.000019   0.000007         let aggregate_errors = syntastic#util#var('aggregate_errors') || len(filetypes) > 1
    1              0.000003         let decorate_errors = aggregate_errors && syntastic#util#var('id_checkers')
    1              0.000003         let sort_aggregated_errors = aggregate_errors && syntastic#util#var('sort_aggregated_errors')
                            
    1              0.000002         let clist = []
    2              0.000003         for type in filetypes
    1   0.000116   0.000010             call extend(clist, s:registry.getCheckers(type, a:checker_names))
    1              0.000001         endfor
                            
    1              0.000002         let names = []
    1              0.000002         let unavailable_checkers = 0
    4              0.000009         for checker in clist
    3   0.000043   0.000027             let cname = checker.getFiletype() . '/' . checker.getName()
    3   0.000220   0.000014             if !checker.isAvailable()
    1   0.000026   0.000017                 call syntastic#log#debug(g:_SYNTASTIC_DEBUG_TRACE, 'CacheErrors: Checker ' . cname . ' is not available')
    1              0.000003                 let unavailable_checkers += 1
    1              0.000002                 continue
                                        endif
                            
    2   0.000029   0.000011             call syntastic#log#debug(g:_SYNTASTIC_DEBUG_TRACE, 'CacheErrors: Invoking checker: ' . cname)
                            
    2   2.361291   0.000034             let loclist = checker.getLocList()
                            
    2   0.000037   0.000027             if !loclist.isEmpty()
                                            if decorate_errors
                                                call loclist.decorate(cname)
                                            endif
                                            call add(names, cname)
                                            if checker.wantSort() && !sort_aggregated_errors
                                                call loclist.sort()
                                                call syntastic#log#debug(g:_SYNTASTIC_DEBUG_LOCLIST, 'sorted:', loclist)
                                            endif
                            
                                            call newLoclist.extend(loclist)
                            
                                            if !aggregate_errors
                                                break
                                            endif
                                        endif
    2              0.000003         endfor
                            
                                    " set names {{{3
    1              0.000004         if !empty(names)
                                        if len(syntastic#util#unique(map( copy(names), 'substitute(v:val, "\\m/.*", "", "")' ))) == 1
                                            let type = substitute(names[0], '\m/.*', '', '')
                                            let name = join(map( names, 'substitute(v:val, "\\m.\\{-}/", "", "")' ), ', ')
                                            call newLoclist.setName( name . ' ('. type . ')' )
                                        else
                                            " checkers from mixed types
                                            call newLoclist.setName(join(names, ', '))
                                        endif
                                    endif
                                    " }}}3
                            
                                    " issue warning about no active checkers {{{3
    1              0.000004         if len(clist) == unavailable_checkers
                                        if !empty(a:checker_names)
                                            if len(a:checker_names) == 1
                                                call syntastic#log#warn('checker ' . a:checker_names[0] . ' is not available')
                                            else
                                                call syntastic#log#warn('checkers ' . join(a:checker_names, ', ') . ' are not available')
                                            endif
                                        else
                                            call syntastic#log#debug(g:_SYNTASTIC_DEBUG_TRACE, 'CacheErrors: no checkers available for ' . &filetype)
                                        endif
                                    endif
                                    " }}}3
                            
    1   0.000026   0.000011         call syntastic#log#debug(g:_SYNTASTIC_DEBUG_LOCLIST, 'aggregated:', newLoclist)
    1              0.000003         if sort_aggregated_errors
                                        call newLoclist.sort()
                                        call syntastic#log#debug(g:_SYNTASTIC_DEBUG_LOCLIST, 'sorted:', newLoclist)
                                    endif
    1              0.000001     endif
                            
    1   0.000152   0.000009     call newLoclist.deploy()

FUNCTION  airline#util#shorten()
Called 39 times
Total time:   0.000447
 Self time:   0.000447

count  total (s)   self (s)
   39              0.000184   if winwidth(0) < a:winwidth && len(split(a:text, '\zs')) > a:minwidth
                                return matchstr(a:text, '^.\{'.a:minwidth.'}').'…'
                              else
   39              0.000058     return a:text
                              endif

FUNCTION  270()
Called 2 times
Total time:   0.000073
 Self time:   0.000056

count  total (s)   self (s)
    2              0.000009     let b:syntastic_private_balloons = {}
    2              0.000007     if has('balloon_eval')
    2   0.000028   0.000011         call syntastic#log#debug(g:_SYNTASTIC_DEBUG_NOTIFICATIONS, 'balloons: reset')
    2              0.000006         unlet! b:syntastic_private_balloons
    2              0.000017         set noballooneval
    2              0.000002     endif

FUNCTION  272()
Called 3 times
Total time:   0.000009
 Self time:   0.000009

count  total (s)   self (s)
    3              0.000005     return self._filetype

FUNCTION  273()
Called 3 times
Total time:   0.000007
 Self time:   0.000007

count  total (s)   self (s)
    3              0.000006     return self._name

FUNCTION  274()
Called 3 times
Total time:   0.000152
 Self time:   0.000077

count  total (s)   self (s)
    3              0.000005     if a:0
                                    let self._exec = a:1
                                else
    3              0.000008         let suffix = self._name . '_exec'
    3   0.000124   0.000049         let self._exec = expand( syntastic#util#var(self._filetype . '_' . suffix, syntastic#util#var(suffix, self._exec_default)), 1 )
    3              0.000005     endif

FUNCTION  276()
Called 2 times
Total time:   0.000039
 Self time:   0.000011

count  total (s)   self (s)
    2   0.000039   0.000011     return syntastic#util#shescape(self._exec)

FUNCTION  278()
Called 2 times
Total time:   2.361257
 Self time:   0.000033

count  total (s)   self (s)
    2   2.361256   0.000032     return g:SyntasticLoclist.New(self.getLocListRaw())

FUNCTION  419()
Called 12 times
Total time:   0.000081
 Self time:   0.000081

count  total (s)   self (s)
   12              0.000061     return get(self._files, a:fname, {})

FUNCTION  <SNR>64__normalise_filetype()
Called 1 time
Total time:   0.000017
 Self time:   0.000017

count  total (s)   self (s)
    1              0.000005     let ft = get(s:_DEFAULT_FILETYPE_MAP, a:ftalias, a:ftalias)
    1              0.000003     let ft = get(g:syntastic_filetype_map, ft, ft)
    1              0.000006     let ft = substitute(ft, '\m-', '_', 'g')
    1              0.000001     return ft

FUNCTION  <SNR>66__add_to_errors()
Called 1 time
Total time:   0.000130
 Self time:   0.000130

count  total (s)   self (s)
    3              0.000009     for err in a:errors
    4              0.000014         for key in keys(a:options)
    2              0.000011             if !has_key(err, key) || empty(err[key])
    2              0.000011                 let err[key] = a:options[key]
    2              0.000003             endif
    2              0.000020         endfor
    2              0.000004     endfor
                            
    1              0.000003     return a:errors

FUNCTION  airline#extensions#branch#get_head()
Called 13 times
Total time:   0.002998
 Self time:   0.000299

count  total (s)   self (s)
   13   0.002778   0.000079   let head = airline#extensions#branch#head()
   13              0.000059   let empty_message = get(g:, 'airline#extensions#branch#empty_message', '')
   13              0.000067   let symbol = get(g:, 'airline#extensions#branch#symbol', g:airline_symbols.branch)
   13              0.000071   return empty(head) ? empty_message : printf('%s%s', empty(symbol) ? '' : symbol.(g:airline_symbols.space), head)

FUNCTION  fugitive#head()
Called 26 times
Total time:   0.000154
 Self time:   0.000154

count  total (s)   self (s)
   26              0.000093   if !exists('b:git_dir')
   26              0.000034     return ''
                              endif
                            
                              return s:repo().head(a:0 ? a:1 : 0)

FUNCTION  282()
Called 2 times
Total time:   0.000907
 Self time:   0.000109

count  total (s)   self (s)
    2              0.000008     let basename = self._filetype . '_' . self._name . '_'
                            
    2              0.000003     let parts = []
    2   0.000222   0.000023     call extend(parts, self._getOpt(a:opts, basename, 'exe', self.getExecEscaped()))
    2   0.000165   0.000015     call extend(parts, self._getOpt(a:opts, basename, 'args', ''))
    2   0.000198   0.000022     call extend(parts, self._getOpt(a:opts, basename, 'fname', syntastic#util#shexpand('%')))
    2   0.000146   0.000013     call extend(parts, self._getOpt(a:opts, basename, 'post_args', ''))
    2   0.000153   0.000013     call extend(parts, self._getOpt(a:opts, basename, 'tail', ''))
                            
    2              0.000007     return join(parts)

FUNCTION  283()
Called 3 times
Total time:   0.000206
 Self time:   0.000054

count  total (s)   self (s)
    3   0.000164   0.000012     call self.syncExec()
                            
    3              0.000008     if !has_key(self, '_available')
                                    let self._available = {}
                                endif
    3              0.000009     if !has_key(self._available, self._exec)
                                    let self._available[self._exec] = self._isAvailableFunc()
                                endif
                            
    3              0.000006     return self._available[self._exec]

FUNCTION  287()
Called 2 times
Total time:   0.000238
 Self time:   0.000141

count  total (s)   self (s)
                                " wildcard quiet_messages
    2   0.000059   0.000019     let quiet_filters = copy(syntastic#util#var('quiet_messages', {}))
    2              0.000010     if type(quiet_filters) != type({})
                                    call syntastic#log#warn('ignoring invalid syntastic_quiet_messages')
                                    unlet quiet_filters
                                    let quiet_filters = {}
                                endif
                            
                                " per checker quiet_messages
    2              0.000009     let name = self._filetype . '_' . self._name
    2              0.000004     try
    2   0.000057   0.000023         call extend( quiet_filters, copy(syntastic#util#var(name . '_quiet_messages', {})), 'force' )
    2              0.000005     catch /\m^Vim\%((\a\+)\)\=:E712/
                                    call syntastic#log#warn('ignoring invalid syntastic_' . name . '_quiet_messages')
                                endtry
                            
    2   0.000038   0.000015     call syntastic#log#debug(g:_SYNTASTIC_DEBUG_LOCLIST, 'quiet_messages filter:', quiet_filters)
                            
    2              0.000006     if !empty(quiet_filters)
                                    call syntastic#util#dictFilter(a:errors, quiet_filters)
                                    call syntastic#log#debug(g:_SYNTASTIC_DEBUG_LOCLIST, 'filtered by quiet_messages:', a:errors)
                                endif

FUNCTION  288()
Called 2 times
Total time:   0.000090
 Self time:   0.000090

count  total (s)   self (s)
    2              0.000009     if has_key(self, '_highlightRegexFunc')
    4              0.000009         for e in a:errors
    2              0.000005             if e['valid']
                                            let term = self._highlightRegexFunc(e)
                                            if term !=# ''
                                                let e['hl'] = term
                                            endif
                                        endif
    2              0.000004         endfor
    2              0.000002     endif

FUNCTION  289()
Called 10 times
Total time:   0.000723
 Self time:   0.000290

count  total (s)   self (s)
   10              0.000021     let ret = []
   10   0.000185   0.000071     call extend( ret, syntastic#util#argsescape(get(a:opts, a:name . '_before', '')) )
   10   0.000309   0.000111     call extend( ret, syntastic#util#argsescape(syntastic#util#var( a:basename . a:name, get(a:opts, a:name, a:default) )) )
   10   0.000185   0.000064     call extend( ret, syntastic#util#argsescape(get(a:opts, a:name . '_after', '')) )
                            
   10              0.000011     return ret

FUNCTION  syntastic#util#rawVar()
Called 45 times
Total time:   0.000297
 Self time:   0.000297

count  total (s)   self (s)
   45              0.000276     return get(b:, a:name, get(g:, a:name, a:0 ? a:1 : ''))

FUNCTION  syntastic#util#shexpand()
Called 2 times
Total time:   0.000036
 Self time:   0.000015

count  total (s)   self (s)
    2   0.000036   0.000015     return syntastic#util#shescape(a:0 ? expand(a:string, a:1) : expand(a:string, 1))

FUNCTION  airline#extensions#hunks#get_hunks()
Called 13 times
Total time:   0.004703
 Self time:   0.000825

count  total (s)   self (s)
   13              0.000056   if !get(w:, 'airline_active', 0)
                                return ''
                              endif
                              " Cache vavlues, so that it isn't called too often
   13              0.000210   if exists("b:airline_hunks") && get(b:,  'airline_changenr', 0) == changenr() && winwidth(0) == get(s:, 'airline_winwidth', 0) && get(b:, 'source_func', '') isnot# 's:get_hunks_signify' && get(b:, 'source_func', '') isnot# 's:get_hunks_gitgutter' && get(b:, 'source_func', '') isnot# 's:get_hunks_empty'
                                return b:airline_hunks
                              endif
   13   0.003955   0.000077   let hunks = s:get_hunks()
   13              0.000027   let string = ''
   13              0.000029   if !empty(hunks)
                                for i in [0, 1, 2]
                                  if (s:non_zero_only == 0 && winwidth(0) > 100) || hunks[i] > 0
                                    let string .= printf('%s%s ', s:hunk_symbols[i], hunks[i])
                                  endif
                                endfor
                              endif
   13              0.000038   let b:airline_hunks = string
   13              0.000039   let b:airline_changenr = changenr()
   13              0.000046   let s:airline_winwidth = winwidth(0)
   13              0.000021   return string

FUNCTION  <SNR>150_Init()
Called 8 times
Total time:   0.000309
 Self time:   0.000309

count  total (s)   self (s)
    8              0.000026     if s:checked_ctags == 2 && a:silent
                                    return 0
                                elseif s:checked_ctags != 1
                                    if !s:CheckForExCtags(a:silent)
                                        return 0
                                    endif
                                endif
                            
    8              0.000014     if !s:checked_ctags_types
                                    call s:GetSupportedFiletypes()
                                endif
                            
    8              0.000012     if !s:type_init_done
                                    call s:InitTypes()
                                endif
                            
    8              0.000013     if !s:autocommands_done
                                    call s:CreateAutocommands()
                                    call s:AutoUpdate(fnamemodify(expand('%'), ':p'), 0)
                                endif
                            
    8              0.000009     return 1

FUNCTION  291()
Called 4 times
Total time:   0.000087
 Self time:   0.000017

count  total (s)   self (s)
    4   0.000086   0.000016     return syntastic#util#var('echo_current_error')

FUNCTION  292()
Called 2 times
Total time:   0.000123
 Self time:   0.000067

count  total (s)   self (s)
    2   0.000082   0.000026     if self.enabled() && !a:loclist.isEmpty()
                                    call syntastic#log#debug(g:_SYNTASTIC_DEBUG_NOTIFICATIONS, 'cursor: refresh')
                                    let b:syntastic_private_messages = copy(a:loclist.messages(bufnr('')))
                                    let b:syntastic_private_line = -1
                                    let b:syntastic_cursor_columns = a:loclist.getCursorColumns()
                                    autocmd! syntastic CursorMoved
                                    autocmd syntastic CursorMoved * call SyntasticRefreshCursor()
                                endif

FUNCTION  293()
Called 2 times
Total time:   0.000048
 Self time:   0.000032

count  total (s)   self (s)
    2   0.000024   0.000008     call syntastic#log#debug(g:_SYNTASTIC_DEBUG_NOTIFICATIONS, 'cursor: reset')
    2              0.000014     autocmd! syntastic CursorMoved
    2              0.000004     unlet! b:syntastic_private_messages
    2              0.000004     let b:syntastic_private_line = -1

FUNCTION  295()
Called 4 times
Total time:   0.000086
 Self time:   0.000026

count  total (s)   self (s)
    4   0.000084   0.000024     return s:has_highlighting && syntastic#util#var('enable_highlighting')

FUNCTION  296()
Called 2 times
Total time:   0.000222
 Self time:   0.000132

count  total (s)   self (s)
    2   0.000046   0.000007     if self.enabled()
    2   0.000033   0.000013         call syntastic#log#debug(g:_SYNTASTIC_DEBUG_NOTIFICATIONS, 'highlighting: refresh')
    2   0.000034   0.000010         call self._reset()
    2              0.000007         let buf = bufnr('')
    2   0.000025   0.000018         let issues = filter(a:loclist.copyRaw(), 'v:val["bufnr"] == buf')
    2              0.000005         for item in issues
                                        let group = 'Syntastic' . get(item, 'subtype', '') . ( item['type'] ==? 'E' ? 'Error' : 'Warning' )
                            
                                        " The function `Syntastic_{filetype}_{checker}_GetHighlightRegex` is
                                        " used to override default highlighting.
                                        if has_key(item, 'hl')
                                            call matchadd(group, '\%' . item['lnum'] . 'l' . item['hl'])
                                        elseif get(item, 'col', 0)
                                            if get(item, 'vcol', 0)
                                                let lastcol = virtcol([item['lnum'], '$'])
                                                let coltype = 'v'
                                            else
                                                let lastcol = col([item['lnum'], '$'])
                                                let coltype = 'c'
                                            endif
                                            let lcol = min([lastcol, item['col']])
                            
                                            call matchadd(group, '\%' . item['lnum'] . 'l\%' . lcol . coltype)
                                        endif
                                    endfor
    2              0.000001     endif

FUNCTION  297()
Called 2 times
Total time:   0.000063
 Self time:   0.000025

count  total (s)   self (s)
    2              0.000004     if s:has_highlighting
    2   0.000025   0.000008         call syntastic#log#debug(g:_SYNTASTIC_DEBUG_NOTIFICATIONS, 'highlighting: reset')
    2   0.000029   0.000008         call self._reset()
    2              0.000002     endif

FUNCTION  299()
Called 4 times
Total time:   0.000045
 Self time:   0.000045

count  total (s)   self (s)
    4              0.000014     for match in getmatches()
                                    if stridx(match['group'], 'Syntastic') == 0
                                        call matchdelete(match['id'])
                                    endif
                                endfor

FUNCTION  syntastic#util#argsescape()
Called 30 times
Total time:   0.000314
 Self time:   0.000314

count  total (s)   self (s)
   30              0.000109     if type(a:opt) == type('') && a:opt !=# ''
    8              0.000013         return [a:opt]
                                elseif type(a:opt) == type([])
                                    return map(copy(a:opt), 'syntastic#util#shescape(v:val)')
                                endif
                            
   22              0.000020     return []

FUNCTION  gitgutter#async#handle_diff_job_vim_close()
Called 2 times
Total time:   0.001560
 Self time:   0.000177

count  total (s)   self (s)
    2   0.000131   0.000023   call gitgutter#debug#log('channel: '.a:channel)
                            
    2   0.000036   0.000016   let channel_id = s:channel_id(a:channel)
    2   0.000034   0.000021   let job_bufnr = s:job_buffer(channel_id)
                            
    2              0.000008   if bufexists(job_bufnr)
    2   0.000021   0.000015     let current_buffer = gitgutter#utility#bufnr()
    2   0.000047   0.000012     call gitgutter#utility#set_buffer(job_bufnr)
                            
    2   0.001156   0.000027     call gitgutter#handle_diff(s:job_output(channel_id))
                            
    2   0.000041   0.000012     call gitgutter#utility#set_buffer(current_buffer)
    2              0.000003   endif
    2   0.000073   0.000030   call s:job_finished(channel_id)

FUNCTION  SyntasticStatuslineFlag()
Called 13 times
Total time:   0.002347
 Self time:   0.000176

count  total (s)   self (s)
   13   0.002338   0.000167     return g:SyntasticLoclist.current().getStatuslineFlag()

FUNCTION  airline#util#prepend()
Called 13 times
Total time:   0.000156
 Self time:   0.000156

count  total (s)   self (s)
   13              0.000040   if a:minwidth > 0 && winwidth(0) < a:minwidth
                                return ''
                              endif
   13              0.000074   return empty(a:text) ? '' : a:text.s:spc.g:airline_right_alt_sep.s:spc

FUNCTION  <SNR>112_ws_refresh()
Called 3 times
Total time:   0.000060
 Self time:   0.000060

count  total (s)   self (s)
    3              0.000036   unlet! b:airline_whitespace_check
    3              0.000013   if get(g:, 'airline_skip_empty_sections', 0)
                                exe ':AirlineRefresh'
                              endif

FUNCTION  gitgutter#handle_diff()
Called 2 times
Total time:   0.001087
 Self time:   0.000164

count  total (s)   self (s)
    2   0.000129   0.000015   call gitgutter#debug#log(a:diff)
                            
    2   0.000025   0.000019   call setbufvar(gitgutter#utility#bufnr(), 'gitgutter_tracked', 1)
                            
    2   0.000110   0.000037   call gitgutter#hunk#set_hunks(gitgutter#diff#parse_diff(a:diff))
    2   0.000095   0.000022   let modified_lines = gitgutter#diff#process_hunks(gitgutter#hunk#hunks())
                            
    2              0.000009   if len(modified_lines) > g:gitgutter_max_signs
                                call gitgutter#utility#warn_once('exceeded maximum number of signs (configured by g:gitgutter_max_signs).', 'max_signs')
                                call gitgutter#sign#clear_signs()
                                return
                              endif
                            
    2              0.000005   if g:gitgutter_signs || g:gitgutter_highlight_lines
    2   0.000657   0.000016     call gitgutter#sign#update_signs(modified_lines)
    2              0.000001   endif
                            
    2   0.000030   0.000014   call gitgutter#utility#save_last_seen_change()

FUNCTION  SyntaxCheckers_php_phpmd_GetLocList()
Called 1 time
Total time:   2.329455
 Self time:   0.000027

count  total (s)   self (s)
    1   0.000462   0.000009     let makeprg = self.makeprgBuild({ 'post_args_before': 'text', 'post_args': 'codesize,design,unusedcode,naming' })
                            
    1              0.000002     let errorformat = '%E%f:%l%\s%#%m'
                            
    1   2.328988   0.000013     return SyntasticMake({ 'makeprg': makeprg, 'errorformat': errorformat, 'subtype' : 'Style' })

FUNCTION  airline#extensions#tabline#tabs#map_keys()
Called 2 times
Total time:   0.000396
 Self time:   0.000396

count  total (s)   self (s)
    2              0.000084   noremap <silent> <Plug>AirlineSelectTab1 :1tabn<CR>
    2              0.000042   noremap <silent> <Plug>AirlineSelectTab2 :2tabn<CR>
    2              0.000034   noremap <silent> <Plug>AirlineSelectTab3 :3tabn<CR>
    2              0.000031   noremap <silent> <Plug>AirlineSelectTab4 :4tabn<CR>
    2              0.000030   noremap <silent> <Plug>AirlineSelectTab5 :5tabn<CR>
    2              0.000028   noremap <silent> <Plug>AirlineSelectTab6 :6tabn<CR>
    2              0.000027   noremap <silent> <Plug>AirlineSelectTab7 :7tabn<CR>
    2              0.000026   noremap <silent> <Plug>AirlineSelectTab8 :8tabn<CR>
    2              0.000027   noremap <silent> <Plug>AirlineSelectTab9 :9tabn<CR>
    2              0.000025   noremap <silent> <Plug>AirlineSelectPrevTab gT
                              " tabn {count} goes to count tab does not go {count} tab pages forward!
    2              0.000038   noremap <silent> <Plug>AirlineSelectNextTab :<C-U>exe repeat(':tabn\|', v:count1)<cr>

FUNCTION  gitgutter#hunk#set_hunks()
Called 2 times
Total time:   0.000010
 Self time:   0.000010

count  total (s)   self (s)
    2              0.000009   let s:hunks = a:hunks

FUNCTION  <SNR>150_ExecuteCtags()
Called 2 times
Total time:   0.014989
 Self time:   0.000408

count  total (s)   self (s)
    2   0.000035   0.000016     call s:debug('Executing ctags command: ' . a:ctags_cmd)
                            
    2              0.000010     if &shell =~# 'fish$'
                                    " Reset shell since fish isn't really compatible
                                    let shell_save = &shell
                                    set shell=sh
                                endif
                            
    2              0.000005     if exists('+shellslash')
                                    let shellslash_save = &shellslash
                                    set noshellslash
                                endif
                            
    2              0.000007     if &shell =~ 'cmd\.exe'
                                    let shellxquote_save = &shellxquote
                                    set shellxquote=\"
                                    let shellcmdflag_save = &shellcmdflag
                                    set shellcmdflag=/s\ /c
                                endif
                            
    2              0.000002     if s:debug
                                    silent 5verbose let ctags_output = system(a:ctags_cmd)
                                    call s:debug(v:statusmsg)
                                    redraw!
                                else
    2   0.014733   0.000171         silent let ctags_output = system(a:ctags_cmd)
    2              0.000020     endif
                            
    2              0.000041     if &shell =~ 'cmd\.exe'
                                    let &shellxquote  = shellxquote_save
                                    let &shellcmdflag = shellcmdflag_save
                                endif
                            
    2              0.000016     if exists('+shellslash')
                                    let &shellslash = shellslash_save
                                endif
                            
    2              0.000009     if exists('shell_save')
                                    let &shell = shell_save
                                endif
                            
    2              0.000010     return ctags_output

FUNCTIONS SORTED ON TOTAL TIME
count  total (s)   self (s)  function
    2   2.365476   0.000073  <SNR>66_BufWritePostHook()
    2   2.365248   0.000302  <SNR>66_UpdateErrors()
    1   2.362888   0.000494  <SNR>66_CacheErrors()
    2   2.361257   0.000033  278()
    2   2.361074   0.000293  277()
    2   2.359395   0.000909  SyntasticMake()
    2   2.358166   0.000549  syntastic#util#system()
    1   2.329455   0.000027  SyntaxCheckers_php_phpmd_GetLocList()
    3   0.035736   0.001006  <SNR>150_AutoUpdate()
    2   0.033629   0.003629  <SNR>150_ProcessFile()
    1   0.030915   0.000041  SyntaxCheckers_php_php_GetLocList()
    2   0.016349   0.000591  <SNR>150_ExecuteCtagsOnFile()
    2   0.014989   0.000408  <SNR>150_ExecuteCtags()
   26   0.009738   0.007089  <SNR>150_ParseTagline()
   26   0.005803   0.004572  airline#extensions#branch#head()
   13   0.004703   0.000825  airline#extensions#hunks#get_hunks()
   13   0.003878   0.000482  <SNR>108_get_hunks()
    3   0.003486   0.000381  gitgutter#process_buffer()
   13   0.003396   0.000137  <SNR>108_get_hunks_gitgutter()
   13   0.003259   0.000155  <SNR>108_is_branch_empty()

FUNCTIONS SORTED ON SELF TIME
count  total (s)   self (s)  function
   26   0.009738   0.007089  <SNR>150_ParseTagline()
   26   0.005803   0.004572  airline#extensions#branch#head()
    2   0.033629   0.003629  <SNR>150_ProcessFile()
   62              0.002075  <SNR>150_CompareByKind()
   13   0.003008   0.001925  airline#extensions#whitespace#check()
    2   0.001896   0.001743  gitgutter#async#execute()
   13              0.001580  airline#check_mode()
   32              0.001220  380()
   13              0.001121  310()
    3   0.035736   0.001006  <SNR>150_AutoUpdate()
   11   0.001102   0.000974  <SNR>150_GetNearbyTag()
   65              0.000936  airline#util#append()
    2   2.359395   0.000909  SyntasticMake()
   26   0.001037   0.000907  386()
   13   0.004703   0.000825  airline#extensions#hunks#get_hunks()
   16              0.000822  300()
  104              0.000807  airline#util#wrap()
    2   0.002353   0.000788  338()
    3              0.000729  <SNR>112_check_mixed_indent()
   32   0.001927   0.000707  379()

